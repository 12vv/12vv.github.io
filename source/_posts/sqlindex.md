---
title: MySQL索引
date: 2019-07-10
tag: [数据库]
categories: [数据库]
---


### 关于索引
数据库建立索引的主要的目的是为了加快查询速度，举一个简单检索图书的例子，<!--more--> 例如我们要在`n`本书里找一本书，没有索引就只能顺序全搜索，那么平均需要时间`n/2`，算法复杂度$O(n/2)$，如果以字母为建立索引，使用二分查找，算法复杂度则变为$O(log(n))$。但是同时，我们需要损失一些磁盘空间来存放索引，在数据的插入和删除也要多做一些调整。

> 如果一个表中有多个索引，必会减慢插入(INSERT)操作，这是因为插入的时候，索引也要做调整，有时候先删除索引，插入数据后再重建索引效率会更高，需要视情况而定。

在主键上，索引会自动被建立，在`MySQL InnoDB`引擎中，在外键上也会建立索引，如果属性值定义为`UNIQUE`的，索引同样被自动建立。

### 索引数据结构

#### B- Tree

![](/images/sqlindex/b-tree.jpg)

- 排序方式：所有节点关键字按递增次序排列。 

- 子节点数：非叶节点的子节点树大于`1`，且小于`M`(M阶代表一个树节点最多有多少个查找路径)，空树除外。

- 关键字树：非叶节点的关键字数量大于等于`ceil(m/2)-1`且小于等于`M-1`。

- 所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子。


#### B+ Tree

![](/images/sqlindex/b+tree.jpeg)

相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。

- B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，这样使得B+树每个非叶子节点所能保存的关键字大大增加。

- B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样，查询速度稳定。

- B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。

- 非叶子节点的子节点数 = 关键字数。

#### Hash Indexes

![](/images/sqlindex/hash.png)

- `Hash 索引`仅仅能满足`等值查询("=","IN" or "<=>")`，不能使用范围查询。

由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样。

- `Hash 索引`无法被用来避免数据的排序操作。

另外，哈希值是按照顺序排列的，但是哈希值映射的真正数据在哈希表中就不一定按照顺序排列，所以无法利用Hash索引来加速任何排序操作。

- `Hash 索引`不能利用部分索引键查询。

对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。

- `Hash 索引`不能避免全表扫描。

Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。

- `Hash 索引`遇到大量Hash值相等的情况后性能也并不一定就会比`B-Tree索引`高。

对于选择性比较低的索引键，如果创建 Hash 索引，那么将会存在大量记录指针信息存于同一个 Hash 值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据的访问，而造成整体性能低下。


### 性能分析

#### 主存存取原理

当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。RAM的存取时间与数据的物理位置无关。

#### 磁盘存取原理

一次访盘请求（读/写）完成过程由三个动作组成：
1. 寻道（时间）：磁头移动定位到指定磁道 
2. 旋转延迟（时间）：等待指定扇区从磁头下旋转经过 
3. 数据传输（时间）：数据在磁盘与内存之间的实际传输


索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此磁盘I/O的时间消耗是巨大的，磁盘的存取速度往往是主存存取速度的几百分分之一。

> 局部性原理: 当一个数据被用到时，其附近的数据也通常会马上被使用。

由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，`预读`可以提高I/O效率。

> 预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。

而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为`O(h)`，效率明显比`B-Tree`差很多。

另外，`B+Tree`更适合外存索引，原因和内节点出度`d`有关。从上面分析可以看到，`d`越大索引的性能越好，而出度的上限取决于节点内`key`和`data`的大小，由于`B+Tree`内节点去掉了`data`域，因此可以拥有更大的出度，拥有更好的性能。

#### MyISAM

`MyISAM`引擎使用`B+Tree`作为索引结构，叶节点的`data`域存放的是数据记录的地址(文件的指针)。下图是MyISAM索引的原理图：

![](/images/sqlindex/mylsam.png)

这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：

![](/images/sqlindex/mylsam1.png)

同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。也称`MyISAM`的索引方式为“非聚集”的。


#### InnoDB

在`InnoDB`中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此`InnoDB`表数据文件本身就是主索引。

对比`MyISAM`的索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

![](/images/sqlindex/innodb.png)

可以看到叶节点包含了完整的数据记录，这种索引叫做聚集索引。

因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。

另外与`MyISAM`索引的不同是`InnoDB`的辅助索引`data`域存储相应记录主键的值而不是地址。

![](/images/sqlindex/innodb1.png)

这里以英文字符的`ASCII`码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。

也不建议在`InnoDB`用非单调的字段作为主键，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

### 总结

- 虽然加快了查询速度，但索引也是有代价的，索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担。

- 如果表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。

- 当索引的选择性较低，也不建议建立索引。

$$
Index Selectivity = Cardinality(不重复的索引值) / #T(表记录数)
$$

### 参考资料
1. [MySQL Index Structure and Performance](https://www.vertabelo.com/blog/technical-articles/all-about-indexes-part-2-mysql-index-structure-and-performance)
2. [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
3. [MySQL的btree索引和hash索引的区别](https://www.cnblogs.com/vicenteforever/articles/1789613.html)