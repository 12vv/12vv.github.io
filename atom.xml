<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jay&#39;s Blog</title>
  
  
  <link href="https://12vv.github.io/atom.xml" rel="self"/>
  
  <link href="https://12vv.github.io/"/>
  <updated>2021-09-30T20:41:02.544Z</updated>
  <id>https://12vv.github.io/</id>
  
  <author>
    <name>Jaythan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码复用模式</title>
    <link href="https://12vv.github.io/2021/09/30/dmfyms/"/>
    <id>https://12vv.github.io/2021/09/30/dmfyms/</id>
    <published>2021-09-30T06:00:00.000Z</published>
    <updated>2021-09-30T20:41:02.544Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>摘自：<em>JavaScript patterns</em> 中译本 - 《JavaScript 模式》第六章</p></blockquote><p>代码复用是一个既重要又有趣的话题。如果你面对自己或者别人已经写好的代码，而这些代码又是经过测试的、可维护的、可扩展的、有文档的，这时候你只想写尽量少且可以被复用的代码就是一个再自然不过的想法。</p><p>当我们说到代码复用的时候，想到的第一件事就是继承，本章会有很大篇幅讲述这个话题，你将看到好多种方法来实现“<code>类式（classical）</code>”和一些其它方式的继承。但是，最最重要的事情，是你需要记住终极目标——<strong>代码复用</strong>。继承是达到这个目标的一种方法，但是不是唯一的。在本章，你将看到怎样基于其它对象来构建新对象，怎样使用混元，以及怎样在不使用继承的情况下只复用你需要的功能。</p><p>在做代码复用的工作的时候，谨记<code>Gang of Four</code>在书中给出的关于对象创建的建议：“<strong>优先使用对象创建而不是类继承</strong>”。</p><p>译注：《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）是一本设计模式的经典书籍，该书作者为Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides，被称为“Gang of Four”，简称“GoF”。</p><h2 id="类式继承-vs-现代继承模式"><a href="#类式继承-vs-现代继承模式" class="headerlink" title="类式继承 vs 现代继承模式"></a>类式继承 vs 现代继承模式</h2><p>在讨论 JavaScript 的继承这个话题的时候，经常会听到“<code>类式继承</code>”的概念，那我们先看一下什么是类式（classical）继承。<code>classical</code>一词并不是来自某些古老的、固定的或者是被广泛接受的解决方案，而仅仅是来自单词“class”。（译注：classical也有“经典”的意思。）</p><p>很多编程语言都有原生的类的概念，以此作为对象的蓝本。在这些语言中，每个对象都是一个指定类的实例（instance），并且（以Java为例）一个对象不能在不存在对应的类的情况下存在。在JavaScript中，因为没有类，所以类的实例的概念没什么意义。JavaScript 的对象仅仅是简单的键值对，这些键值对都可以动态创建或者是改变。</p><p>但是 JavaScript 拥有<code>构造函数(constructor functions)</code>，并且有语法和使用类非常相似的<code>new</code>运算符。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Java 中你可能会这样写</span></span><br><span class="line">Person adam = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JavaScript中你可以这样</span></span><br><span class="line"><span class="keyword">var</span> adam = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>除了 Java 是强类型语言需要给<code>adam</code>添加类型<code>Person</code>外，其它的语法看起来是一样的。JavaScript 的构造函数调用方式看起来让人感觉<code>Person()</code>是一个类，但事实上，<code>Person()</code>仅仅是一个函数。语法上的相似使得非常多的开发者陷入对 JavaScript 类的思考，并且给出了很多模拟类的继承方案。这样的实现方式，我们叫它“<code>类式继承</code>”。顺便也提一下，所谓“现代”继承模式是指那些不需要你去想类这个概念的模式。</p><p>当需要给项目选择一个继承模式时，有不少的备选方案。你应该尽量选择那些现代继承模式，除非团队已经觉得“无类不欢”。</p><p>本章先讨论类式继承，然后再关注现代继承模式。</p><h2 id="类式继承的期望结果"><a href="#类式继承的期望结果" class="headerlink" title="类式继承的期望结果"></a>类式继承的期望结果</h2><p>实现类式继承的目标是基于构造函数<code>Child()</code>来创建一个对象，然后从另一个构造函数<code>Parent()</code>获得属性。</p><p>尽管我们是在讨论类式继承，但还是尽量避免使用“类”这个词。“<code>构造函数</code>”或者“<code>constructor</code>”虽然更长，但是更准确，不会让人迷惑。通常情况下，应该努力避免在跟团队沟通的时候使用“类”这个词，因为在 JavaScript 中，很可能每个人都会有不同的理解。</p><p>下面是定义两个构造函数<code>Parent()</code>和<code>Child()</code>的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Parent构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型增加方法</span></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空的Child构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line">inherit(Child, Parent);</span><br></pre></td></tr></table></figure><p>上面的代码定义了两个构造函数<code>Parent()</code>和<code>Child()</code>，<code>say()</code>方法被添加到了<code>Parent()</code>构建函数的<code>原型 (prototype)</code>中，<code>inherit()</code>函数完成了继承的工作。<code>inherit()</code>函数并不是原生提供的，需要自己实现。让我们来看一看比较常见的实现它的几种方法。</p><h2 id="类式继承1——默认模式"><a href="#类式继承1——默认模式" class="headerlink" title="类式继承1——默认模式"></a>类式继承1——默认模式</h2><p>最常用的一种模式是使用<code>Parent()</code>构造函数来创建一个对象，然后把这个对象设为<code>Child()</code>的原型。这是可复用的<code>inherit()</code>函数的第一种实现方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">C.prototype = <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要强调的是原型（<code>prototype</code>属性）应该<strong>指向一个对象，而不是函数</strong>，所以它需要指向由被继承的构造函数创建的实例（对象），而不是构造函数自己。换句话说，请注意<code>new</code>运算符，有了它这种模式才可以正常工作。</p><p>之后在应用中使用<code>new Child()</code>创建对象的时候，它将通过原型拥有<code>Parent()</code>实例的功能，像下面的例子一样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br><span class="line">kid.say(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure><h3 id="跟踪原型链"><a href="#跟踪原型链" class="headerlink" title="跟踪原型链"></a>跟踪原型链</h3><p>在这种模式中，子对象既继承了（父对象的）“<code>自有属性</code>”（添加给<code>this</code>的实例属性，比如<code>name</code>），<strong>也继承了原型中的属性和方法</strong>（比如<code>say()</code>）。</p><p>我们来看一下在这种继承模式中原型链是怎么工作的。为了讨论方便，我们假设对象是内存中的一块空间，它包含数据和指向其它空间的引用。当使用<code>new Parent()</code>创建一个对象时，这样的一块空间就被分配了（图6-1中的2号），它保存着<code>name</code>属性的数据。如果你尝试访问<code>say()</code>方法（比如通过<code>(new Parent).say()</code>），2号空间中并没有这个方法。但是在通过隐藏的链接<code>__proto__</code>指向<code>Parent()</code>构建函数的原型<code>prototype</code>属性时，就可以访问到包含<code>say()</code>方法的1号空间（<code>Parent.prototype</code>）了。</p><p>所有的这一块都是在幕后发生的，不需要任何额外的操作，但是知道它是怎样工作的有助于让你明白你正在访问或者修改的数据在哪，这是很重要的。注意，<code>__proto__</code>在这里只是为了解释原型链而存在，这个属性在语言本身中是不可用的，尽管有一些环境提供了（比如Firefox）。</p><p><img src="/images/dmfyms/1.png" alt="/images/dmfyms/1.png"></p><p>图6-1 Parent()构造函数的原型链</p><p>现在我们来看一下在使用<code>inherit()</code>函数之后再使用<code>var kid = new Child()</code>创建一个新对象时会发生什么。见图6-2。</p><p><img src="/images/dmfyms/2.png" alt="/images/dmfyms/2.png"></p><p>图6-2 继承后的原型链</p><p><code>Child()</code>构造函数是空的，也没有属性添加到<code>Child.prototype</code>上，这样，使用<code>new Child()</code>创建出来的对象都是空的，除了有隐藏的链接<code>__proto__</code>。在这个例子中，<code>__proto__</code>指向在<code>inherit()</code>函数中创建的<code>new Parent()</code>对象。</p><p>现在使用<code>kid.say()</code>时会发生什么？<code>3</code>号对象没有这个方法，所以通过原型链找到<code>2</code>号。<code>2</code>号对象也没有这个方法，所以也通过原型链找到<code>1</code>号，刚好有这个方法。接下来<code>say()</code>方法引用了<code>this.name</code>，这个变量也需要解析，于是沿原型链查找的过程又走了一遍。在这个例子中，<code>this</code>指向<code>3</code>号对象，它没有<code>name</code>属性，然后<code>2</code>号对象被访问，并且有<code>name</code>属性，值为“<code>Adam</code>”。</p><p>最后，我们看一点额外的东西，假如我们有如下的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br><span class="line">kid.name = <span class="string">"Patrick"</span>;</span><br><span class="line">kid.say(); <span class="comment">// "Patrick"</span></span><br></pre></td></tr></table></figure><p><img src="/images/dmfyms/3.png" alt="/images/dmfyms/3.png"></p><p>图6-3 继承并且给子对象添加属性后的原型链</p><p>设定<code>kid.name</code>并没有改变<code>2</code>号对象的<code>name</code>属性，但是却直接在<code>3</code>号对象上添加了自有的<code>name</code>属性。当<code>kid.say()</code>执行时，<code>say()</code>方法会依次在<code>3</code>号对象中找，然后是<code>2</code>号，最后到<code>1</code>号，像前面说的一样。但是这一次在找<code>this.name</code>（和kid.name一样）时很快，因为这个属性在<code>3</code>号对象中就被找到了。</p><p>如果通过<code>delete kid.name</code>的方式移除新添加的属性，那么<code>2</code>号对象的<code>name</code>属性就将被暴露出来并且在查找的时候被找到。</p><h2 id="这种模式的缺点"><a href="#这种模式的缺点" class="headerlink" title="这种模式的缺点"></a>这种模式的缺点</h2><p>这种模式的一个缺点是既继承了（父对象的）“自有属性”，也继承了原型中的属性。大部分情况下你可能并不需要“自有属性”，因为它们更可能是为实例对象添加的，并不用于复用。</p><blockquote><p><strong>一个在构造函数上常用的规则是，用于复用的成员（译注：属性和方法）应该被添加到原型上。</strong></p></blockquote><p>在使用这个<code>inherit()</code>函数时另外一个不便是它不能够让你传参数给子构造函数，这些参数有可能是想再传给父构造函数的。考虑下面的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Child(<span class="string">'Seth'</span>);</span><br><span class="line">s.say(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure><p>这并不是我们期望的结果。事实上传递参数给父构造函数是可能的，但这样需要在每次需要一个子对象时再做一次继承，很不方便，因为需要不断地创建父对象。</p><h2 id="类式继承2——借用构造函数"><a href="#类式继承2——借用构造函数" class="headerlink" title="类式继承2——借用构造函数"></a>类式继承2——借用构造函数</h2><p>下面这种模式解决了从子对象传递参数到父对象的问题。它借用了父对象的构造函数，将子对象绑定到<code>this</code>，同时传入参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">a, c, b, d</span>) </span>&#123;</span><br><span class="line">Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这种模式时，只能继承在父对象的构造函数中添加到this的属性，不能继承原型上的成员。</p><p>使用借用构造函数的模式，子对象<strong>通过复制</strong>的方式继承父对象的成员，而不是像类式继承<code>1</code>中那样通过<strong>引用</strong>的方式。下面的例子展示了这两者的不同：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.tags = [<span class="string">'js'</span>, <span class="string">'css'</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> article = <span class="keyword">new</span> Article();</span><br><span class="line"></span><br><span class="line"><span class="comment">//BlogPost通过类式继承1（默认模式）从article继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">BlogPost.prototype = article;</span><br><span class="line"><span class="keyword">var</span> blog = <span class="keyword">new</span> BlogPost();</span><br><span class="line"><span class="comment">//注意你不需要使用 **new Article()**，因为已经有一个实例了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//StaticPage 通过借用构造函数的方式从 Article 继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StaticPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">Article.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> page = <span class="keyword">new</span> StaticPage();</span><br><span class="line"></span><br><span class="line">alert(article.hasOwnProperty(<span class="string">'tags'</span>)); <span class="comment">// true</span></span><br><span class="line">alert(blog.hasOwnProperty(<span class="string">'tags'</span>)); <span class="comment">// false</span></span><br><span class="line">alert(page.hasOwnProperty(<span class="string">'tags'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在上面的代码片段中，<code>Article()</code>被用两种方式分别继承。默认模式使<code>blog</code>可以通过原型链访问到<code>tags</code>属性，所以它自己并没有<code>tags</code>属性，<code>hasOwnProperty()</code>返回<code>false</code>。<code>page</code>对象有自己的<code>tags</code>属性，因为它是使用借用构造函数的方式继承，复制（而不是引用）了<code>tags</code>属性。</p><p>注意在修改继承后的<code>tags</code>属性时的不同表现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blog.tags.push(<span class="string">'html'</span>);</span><br><span class="line">page.tags.push(<span class="string">'php'</span>);</span><br><span class="line">alert(article.tags.join(<span class="string">', '</span>)); <span class="comment">// "js, css, html"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>blog</code>对象修改了<code>tags</code>属性，同时，它也修改了父对象，因为实际上<code>blog.tags</code>和<code>article.tags</code>是引向同一个数组。而对<code>pages.tags</code>的修改并不影响父对象<code>article</code>，因为<code>pages.tags</code>在继承的时候是一份独立的拷贝。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>我们来看一下当我们使用熟悉的<code>Parent()</code>和<code>Child()</code>构造函数和这种继承模式时原型链是什么样的。为了使用这种继承模式，<code>Child()</code>有明显变化：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原型上添加方法</span></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child(<span class="string">"Patrick"</span>);</span><br><span class="line">kid.name; <span class="comment">// "Patrick"</span></span><br><span class="line"><span class="keyword">typeof</span> kid.say; <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure><p>如果看一下 图6-4，就能发现<code>new Child()</code>对象和<code>Parent()</code>之间不再有链接。这是因为<code>Child.prototype</code>根本就没有被使用，它指向一个空对象。使用这种模式，<code>kid</code>拥有了自有的<code>name</code>属性，但是并没有继承<code>say()</code>方法，如果尝试调用它的话会出错。这种继承方式只是一种一次性地将父对象的属性复制为子对象的属性，并没有<code>__proto__</code>链接。</p><p><img src="/images/dmfyms/4.png" alt="/images/dmfyms/4.png"></p><p>图6-4 使用借用构造函数模式时没有被关联的原型链</p><h3 id="利用借用构造函数模式实现多继承"><a href="#利用借用构造函数模式实现多继承" class="headerlink" title="利用借用构造函数模式实现多继承"></a>利用借用构造函数模式实现多继承</h3><p>使用借用构造函数模式，可以通过借用多个构造函数的方式来实现多继承：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.legs = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"meaowww"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.wings = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">this</span>.fly = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CatWings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">Cat.apply(<span class="keyword">this</span>);</span><br><span class="line">Bird.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> CatWings();</span><br><span class="line"><span class="built_in">console</span>.dir(jane);</span><br></pre></td></tr></table></figure><p>结果如 图6-5，任何重复的属性都会以最后的一个值为准。</p><p><img src="/images/dmfyms/5.png" alt="/images/dmfyms/5.png"></p><p>图6-5 在Firebug中查看CatWings对象</p><h3 id="借用构造函数的利与弊"><a href="#借用构造函数的利与弊" class="headerlink" title="借用构造函数的利与弊"></a>借用构造函数的利与弊</h3><p>这种模式的一个明显的弊端就是<strong>无法继承原型</strong>。如前面所说，原型往往是添加可复用的方法和属性的地方，这样就不用在每个实例中再创建一遍。</p><p>这种模式的一个好处是获得了父对象自有成员的拷贝，不存在子对象意外改写父对象属性的风险。</p><p>那么，在上一个例子中，怎样使一个子对象也能够继承原型属性呢？怎样能使kid可以访问到say()方法呢？下一种继承模式解决了这个问题。</p><h2 id="类式继承3——借用并设置原型"><a href="#类式继承3——借用并设置原型" class="headerlink" title="类式继承3——借用并设置原型"></a>类式继承3——借用并设置原型</h2><p>综合以上两种模式，首先借用父对象的构造函数，然后将子对象的原型设置为父对象的一个新实例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">a, c, b, d</span>) </span>&#123;</span><br><span class="line">Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure><p>这样做的好处是子对象获得了父对象的自有成员，也获得了父对象中可复用的（在原型中实现的）方法。子对象也可以传递任何参数给父构造函数。这种行为可能是最接近 Java 的，子对象继承了父对象的所有东西，同时可以安全地修改自己的属性而不用担心修改到父对象。</p><p>一个弊端是父构造函数被调用了两次，所以不是很高效。最后，（父对象的）自有属性（比如这个例子中的<code>name</code>）也被继承了两次。</p><p>我们来看一下代码并做一些测试：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name || <span class="string">'Adam'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原型上添加方法</span></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child(<span class="string">"Patrick"</span>);</span><br><span class="line">kid.name; <span class="comment">// "Patrick"</span></span><br><span class="line">kid.say(); <span class="comment">// "Patrick"</span></span><br><span class="line"><span class="keyword">delete</span> kid.name;</span><br><span class="line">kid.say(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure><p>跟前一种模式不一样，现在<code>say()</code>方法被正确地继承了。可以看到<code>name</code>也被继承了两次，在删除掉自己的拷贝后，在原型链上的另一个就被暴露出来了。</p><p>图6-6展示了这些对象之间的关系。这些关系有点像 图6-3中展示的，但是获得这种关系的方法是不一样的。</p><p><img src="/images/dmfyms/6.png" alt="/images/dmfyms/6.png"></p><p>图6-6 除了继承“自己的属性”外，原型链也被保留了</p><h2 id="类式继承4——共享原型"><a href="#类式继承4——共享原型" class="headerlink" title="类式继承4——共享原型"></a>类式继承4——共享原型</h2><p>不像前一种类式继承模式需要调用两次父构造函数，下面这种模式根本不会涉及到调用父构造函数的问题。</p><p>一般的经验是<strong>将可复用的成员放入原型</strong>中而不是<code>this</code>。从继承的角度来看，则是任何应该被继承的成员都应该放入原型中。这样你只需要设定子对象的原型和父对象的原型一样即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">C.prototype = P.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式的原型链很短并且查找很快，因为所有的对象实际上共享着同一个原型。但是这样也有弊端，那就是如果子对象或者在继承关系中的某个地方的任何一个子对象修改这个原型，将影响所有的继承关系中的父对象。（译注：指会影响到所有从这个原型中继承的对象所依赖的共享原型上的成员。）</p><p>如 图6-7，子对象和父对象共享同一个原型，都可以访问<code>say()</code>方法。但是，子对象不继承<code>name</code>属性。</p><p><img src="/images/dmfyms/7.png" alt="/images/dmfyms/7.png"></p><p>图6-7 （父子对象）共享原型时的关系</p><h2 id="类式继承5——临时构造函数"><a href="#类式继承5——临时构造函数" class="headerlink" title="类式继承5——临时构造函数"></a>类式继承5——临时构造函数</h2><p>下一种模式通过打断父对象和子对象原型的直接链接解决了共享原型时的问题，同时还从原型链中获得其它的好处。</p><p>下面是这种模式的一种实现方式，<code>F()</code>函数是一个空函数，它充当了子对象和父对象的代理。<code>F()</code>的<code>prototype</code>属性指向父对象的原型。子对象的原型是这个空函数的一个实例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = P.prototype;</span><br><span class="line">C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式有一种和默认模式（类式继承1）明显不一样的行为，因为在这里子对象只继承原型中的属性（图6-8）。</p><p><img src="/images/dmfyms/8.png" alt="/images/dmfyms/8.png"></p><p>图6-8 使用临时（代理）构造函数F()实现类式继承</p><p>这种模式通常情况下都是一种很棒的选择，因为原型本来就是存放复用成员的地方。在这种模式中，父构造函数添加到<code>this</code>中的任何成员都不会被继承。</p><p>我们来创建一个子对象并且检查一下它的行为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure><p>如果你访问<code>kid.name</code>将得到<code>undefined</code>。在这个例子中，<code>name</code>是父对象自己的属性，而在继承的过程中我们并没有调用<code>new Parent()</code>，所以这个属性并没有被创建。当访问<code>kid.say()</code>时，它在<code>3</code>号对象中不可用，所以在原型链中查找，<code>4</code>号对象也没有，但是<code>1</code>号对象有，它在内存中的位置会被所有从<code>Parent()</code>创建的构造函数和子对象所共享。</p><h3 id="存储父类（Superclass）"><a href="#存储父类（Superclass）" class="headerlink" title="存储父类（Superclass）"></a>存储父类（Superclass）</h3><p>在上一种模式的基础上，还可以添加一个指向原始父对象的引用。这很像其它语言中访问<code>超类（superclass)</code>的情况，有时候很方便。</p><p>我们将这个属性命名为“<code>uber</code>”，因为“<code>super</code>”是一个保留字，而“<code>superclass</code>”则可能误导别人认为JavaScript 拥有类。下面是这种类式继承模式的一个改进版实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = P.prototype;</span><br><span class="line">C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">C.uber = P.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重置构造函数引用"><a href="#重置构造函数引用" class="headerlink" title="重置构造函数引用"></a>重置构造函数引用</h3><p>这个近乎完美的模式上还需要做的最后一件事情就是重置<code>构造函数 (constructor)</code>的指向，以便未来在某个时刻能被正确地使用。</p><p>如果不重置构造函数的指向，那所有的子对象都会认为<code>Parent()</code>是它们的构造函数，而这个结果完全没有用。使用前面的<code>inherit()</code>的实现，你可以观察到这种行为：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent，Child，实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br><span class="line">kid.constructor.name; <span class="comment">// "Parent"</span></span><br><span class="line">kid.constructor === Parent; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>constructor</code>属性很少被用到，但是在运行时检查对象很方便。你可以重新将它指向期望的构造函数而不影响功能，因为这个属性更多是“信息性”的。（译注：即它更多的时候是在提供信息而不是参与到函数功能中。）</p><p>最终，这种类式继承的<code>Holy Grail</code>版本看起来是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = P.prototype;</span><br><span class="line">C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">C.uber = P.prototype;</span><br><span class="line">C.prototype.constructor = C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似这样的函数也存在于<code>YUI</code>库（也许还有其它库）中，它将类式继承的方法带给了没有类的语言。如果你决定使用类式继承，那么这是最好的方法。</p><blockquote><p>“<code>代理函数</code>”或者“<code>代理构造函数</code>”也是指这种模式，因为临时构造函数是被用作获取父构造函数原型的代理。</p></blockquote><p>一种常见的对<code>Holy Grail</code>模式的优化是<strong>避免每次需要继承的时候都创建一个临时（代理）构造函数</strong>。事实上创建一次就足够了，以后只需要修改它的原型即可。你可以用一个即时函数来将代理函数存储到闭包中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">F.prototype = P.prototype;</span><br><span class="line">C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">C.uber = P.prototype;</span><br><span class="line">C.prototype.constructor = C;</span><br><span class="line">&#125;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h2 id="Klass"><a href="#Klass" class="headerlink" title="Klass"></a>Klass</h2><p>有很多<code>JavaScript</code>类库模拟了类，创造了新的语法糖。这些类库具体的实现方式可能会不一样，但是基本上都有一些共性，包括：</p><ul><li>有一个约定好的方法，如<code>initialize</code>、<code>_init</code>或者其它相似的名字，会被自动调用，来充当类的构造函数</li><li>类可以从其它类继承</li><li>在子类中可以访问到父类（superclass）</li></ul><blockquote><p>我们在这里做一点变化，在本章的这部分自由地使用<code>class</code>这个词，因为主题就是模拟类。</p></blockquote><p>为避免讨论太多细节，我们来看一下<code>JavaScript</code>中一种模拟类的实现。首先，看一下这种方案将如何被使用？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Man = klass(<span class="literal">null</span>, &#123;</span><br><span class="line">__construct: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Man's constructor"</span>);</span><br><span class="line"><span class="keyword">this</span>.name = what;</span><br><span class="line">&#125;,</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这种语法糖的形式是一个名为<code>klass()</code>的函数。在一些其它的实现方式中，它可能是<code>Klass()</code>构造函数或者是增强的<code>Object.prototype</code>，但是在这个例子中，我们让它只是一个简单的函数。</p><p>这个函数接受两个参数：一个被继承的类和通过对象字面量提供的新类的实现。受PHP的影响，我们约定类的构造函数必须是一个名为<code>__construct()</code>的方法。在前面的代码片段中，建立了一个名为<code>Man</code>的新类，并且它不继承任何类（意味着继承自<code>Object</code>）。<code>Man</code>类有一个在<code>__construct()</code>建立的自有属性<code>name</code>和一个方法<code>getName()</code>。这个类是一个构造函数，所以下面的代码将正常工作（并且看起来像类实例化的过程）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> Man(<span class="string">'Adam'</span>); <span class="comment">// logs "Man's constructor"</span></span><br><span class="line">first.getName(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure><p>现在我们来扩展这个类，创建一个<code>SuperMan</code>类：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SuperMan = klass(Man, &#123;</span><br><span class="line">__construct: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"SuperMan's constructor"</span>);</span><br><span class="line">&#125;,</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> name = SuperMan.uber.getName.call(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"I am "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里，<code>klass()</code>的第一个参数是将被继承的<code>Man</code>类。值得注意的是，在<code>getName()</code>中，父类的<code>getName()</code>方法首先通过<code>SuperMan</code>类的<code>uber</code>静态属性被调用。我们来测试一下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clark = <span class="keyword">new</span> SuperMan(<span class="string">'Clark Kent'</span>);</span><br><span class="line">clark.getName(); <span class="comment">// "I am Clark Kent"</span></span><br></pre></td></tr></table></figure><p>第一行在<code>console</code>中记录了“<code>Man&#39;s constructor</code>”，然后是“<code>Superman&#39;s constructor</code>”，在一些语言中，父类的构造函数在子类构造函数被调用的时候会自动执行，这个特性也被模拟了。</p><p>用<code>instanceof</code>运算符测试返回希望的结果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clark <span class="keyword">instanceof</span> Man; <span class="comment">// true</span></span><br><span class="line">clark <span class="keyword">instanceof</span> SuperMan; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>最后，我们来看一下<code>klass()</code>函数是怎样实现的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> klass = <span class="function"><span class="keyword">function</span> (<span class="params">Parent, props</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child, F, i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 构造函数</span></span><br><span class="line">Child = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Child.uber &amp;&amp; Child.uber.hasOwnProperty(<span class="string">"__construct"</span>)) &#123;</span><br><span class="line">Child.uber.__construct.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Child.prototype.hasOwnProperty(<span class="string">"__construct"</span>)) &#123;</span><br><span class="line">Child.prototype.__construct.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 继承</span></span><br><span class="line">Parent = Parent || <span class="built_in">Object</span>;</span><br><span class="line">F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">F.prototype = Parent.prototype;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">Child.uber = Parent.prototype;</span><br><span class="line">Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加方法实现</span></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> props) &#123;</span><br><span class="line"><span class="keyword">if</span> (props.hasOwnProperty(i)) &#123;</span><br><span class="line">Child.prototype[i] = props[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回“类”</span></span><br><span class="line"><span class="keyword">return</span> Child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个<code>klass()</code>实现有三个明显的部分：</p><ol><li>创建<code>Child()</code>构造函数，这也是最后返回的将被作为类使用的函数。在这个函数里面，如果<code>__construct()</code>方法存在的话将被调用，同样，如果父类的<code>__construct()</code>存在，也将被调用（通过使用静态属性<code>uber</code>）。也可能存在<code>uber</code>没有定义的情况——比如从<code>Object</code>继承，前例中<code>Man</code>类即是如此。</li><li>第二部分主要完成继承。只是简单地使用前面章节讨论过的Holy Grail类式继承模式。只有一个东西是新的：如果<code>Parent</code>没有传值的话，设定<code>Parent</code>为<code>Object</code>。</li><li>最后一部分是真正定义类的地方，遍历需要实现的方法（如例子中的<code>__constructor()</code>和<code>getName()</code>），并将它们添加到<code>Child()</code>的原型中。</li></ol><p>什么时候使用这种模式呢？其实，最好是能避免则避免，因为它带来了在这门语言中不存在的完整的类的概念，会让人疑惑。使用它需要学习新的语法和新的规则，也就是说，如果你或者你的团队习惯于使用类并且对原型感到不习惯，这种模式可能是一个可以探索的方向。这种模式允许你完全忘掉原型，好处就是你可以使用像其它语言那样的（变种）语法。</p><h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>现在，让我们从一个叫作“原型继承”的模式来讨论没有类的现代继承模式。在这种模式中，没有任何类牵涉进来，一个对象继承自另外一个对象。你可以这样理解它：你有一个想复用的对象，然后你想创建第二个对象，并且获得第一个对象的功能。下面是这种模式的用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要继承的对象</span></span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">name: <span class="string">"Papa"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新对象</span></span><br><span class="line"><span class="keyword">var</span> child = object(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">alert(child.name); <span class="comment">// "Papa"</span></span><br></pre></td></tr></table></figure><p>在这个代码片段中，有一个已经存在的使用对象字面量创建的对象叫<code>parent</code>，我们想创建一个和<code>parent</code>有相同的属性和方法的对象叫<code>child</code>。<code>child</code>对象使用<code>object()</code>函数创建。这个函数在<code>JavaScript</code>中并不存在（不要与构造函数<code>Object()</code>混淆），所以我们来看看怎样定义它。</p><p>与<code>Holy Grail</code>类式继承相似，可以使用一个空的临时构造函数<code>F()</code>，然后设定<code>F()</code>的原型为<code>parent</code>对象。最后，返回一个临时构造函数的新实例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = o;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图6-9</strong> 展示了使用原型继承时的原型链。这样创建的<code>child</code>总是一个空对象，它没有自有属性但通过原型链（<strong>proto</strong>）拥有父对象的所有功能。</p><p><img src="/images/dmfyms/9.png" alt="/images/dmfyms/9.png"></p><p>图6-9 原型继承模式</p><p><strong>讨论</strong></p><p>在原型继承模式中，<code>parent</code>不一定需要使用对象字面量来创建（尽管这是一种常用的方式），也可以使用构造函数来创建。注意，如果你这样做，那么自有属性和原型上的属性都将被继承：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 自有属性</span></span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"Adam"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型上的属性</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Person()创建一个新对象</span></span><br><span class="line"><span class="keyword">var</span> papa = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">var</span> kid = object(papa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：自有属性和原型上的属性都被继承了</span></span><br><span class="line">kid.getName(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure><p>也可以使用这种模式的一个变种，只继承已存在的构造函数的原型对象。记住，对象继承自对象，而不管父对象是怎么创建的。这是前面例子的一个修改版本：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 自有属性</span></span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">"Adam"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型上的属性</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">var</span> kid = object(Person.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> kid.getName; <span class="comment">// "function"，因为它在原型中</span></span><br><span class="line"><span class="keyword">typeof</span> kid.name; <span class="comment">// "undefined"，因为只有原型中的成员被继承了</span></span><br></pre></td></tr></table></figure><h3 id="ECMAScript5中的原型继承"><a href="#ECMAScript5中的原型继承" class="headerlink" title="ECMAScript5中的原型继承"></a>ECMAScript5中的原型继承</h3><p>在<code>ECMAScript5</code>中，原型继承已经正式成为语言的一部分。这种模式使用<code>Object.create()</code>方法来实现。换句话说，你不再需要自己去写类似<code>object()</code>的函数，它是语言原生的部分了：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent);</span><br></pre></td></tr></table></figure><p><code>Object.create()</code>接收一个额外的参数——一个对象。这个额外对象中的属性将被作为自有属性添加到返回的子对象中。这让我们可以很方便地将继承和创建子对象在一个方法调用中实现。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">age: &#123; <span class="attr">value</span>: <span class="number">2</span> &#125; <span class="comment">// ES5中的属性描述符</span></span><br><span class="line">&#125;);</span><br><span class="line">child.hasOwnProperty(<span class="string">"age"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>你可能也会发现原型继承模式已经在一些<code>JavaScript</code>类库中实现了，比如，在<code>YUI3</code>中，它是<code>Y.Object()</code>方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YUI().use(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> child = Y.Object(parent);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="通过复制属性继承"><a href="#通过复制属性继承" class="headerlink" title="通过复制属性继承"></a>通过复制属性继承</h2><p>让我们来看一下另外一种继承模式——通过复制属性继承。在这种模式中，一个对象通过简单地复制另一个对象来获得功能。下面是一个简单的实现这种功能的<code>extend()</code>函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line">child = child || &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (parent.hasOwnProperty(i)) &#123;</span><br><span class="line">child[i] = parent[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个简单的实现，仅仅是遍历了父对象的成员然后复制它们。在这个实现中，<code>child</code>是可选参数，如果它没有被传入一个已有的对象，那么一个全新的对象将被创建并返回：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dad = &#123;<span class="attr">name</span>: <span class="string">"Adam"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> kid = extend(dad);</span><br><span class="line">kid.name; <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure><p>上面给出的实现叫作对象的 <code>浅拷贝(shallow copy)</code> ，与之相对，<code>深拷贝</code>是指检查准备复制的属性本身是否是对象或者数组，如果是，也遍历它们的属性并复制。如果使用浅拷贝的话（因为在<code>JavaScript</code>中对象是按引用传递），如果你改变子对象的一个属性，而这个属性恰好是一个对象，那么你也会改变父对象。实际上这对方法来说可能很好（因为函数也是对象，也是按引用传递），但是当遇到其它的对象和数组的时候可能会有些意外情况。考虑这种情况：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dad = &#123;</span><br><span class="line">counts: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">reads: &#123;<span class="attr">paper</span>: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> kid = extend(dad);</span><br><span class="line">kid.counts.push(<span class="number">4</span>);</span><br><span class="line">dad.counts.toString(); <span class="comment">// "1,2,3,4"</span></span><br><span class="line">dad.reads === kid.reads; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>现在让我们来修改一下<code>extend()</code>函数以便实现深拷贝。你需要做的事情只是检查一个属性的类型是否是对象，如果是，则递归遍历它的属性。另外一个需要做的检查是这个对象是真的对象还是数组，可以使用第三章讨论过的数组检查方式。最终深拷贝版的<code>extend()</code>是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendDeep</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> i,</span><br><span class="line">toStr = <span class="built_in">Object</span>.prototype.toString,</span><br><span class="line">astr = <span class="string">"[object Array]"</span>;</span><br><span class="line"></span><br><span class="line">child = child || &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> parent) &#123;</span><br><span class="line"><span class="keyword">if</span> (parent.hasOwnProperty(i)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> parent[i] === <span class="string">"object"</span>) &#123;</span><br><span class="line">child[i] = (toStr.call(parent[i]) === astr) ? [] : &#123;&#125;;</span><br><span class="line">extendDeep(parent[i], child[i]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">child[i] = parent[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在测试时这个新的实现给了我们对象的真实拷贝，所以子对象不会修改父对象：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dad = &#123;</span><br><span class="line">counts: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">reads: &#123;<span class="attr">paper</span>: <span class="literal">true</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> kid = extendDeep(dad);</span><br><span class="line"></span><br><span class="line">kid.counts.push(<span class="number">4</span>);</span><br><span class="line">kid.counts.toString(); <span class="comment">// "1,2,3,4"</span></span><br><span class="line">dad.counts.toString(); <span class="comment">// "1,2,3"</span></span><br><span class="line"></span><br><span class="line">dad.reads === kid.reads; <span class="comment">// false</span></span><br><span class="line">kid.reads.paper = <span class="literal">false</span>;</span><br><span class="line">kid.reads.web = <span class="literal">true</span>;</span><br><span class="line">dad.reads.paper; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>通过复制属性继承的模式很简单且应用很广泛。例如 <strong>Firebug</strong>(JavaScript 写的 Firefox 扩展) 有一个方法叫<code>extend()</code>做浅拷贝，<code>jQuery</code>的<code>extend()</code>方法做深拷贝。<code>YUI3</code>提供了一个叫作<code>Y.clone()</code>的方法，它创建一个深拷贝并且通过绑定到子对象的方式复制函数。（本章后面将有更多关于绑定的内容。）</p><p>这种模式并不高深，因为根本没有原型牵涉进来，而只跟对象和它们的属性有关。</p><h2 id="混元-Mix-ins"><a href="#混元-Mix-ins" class="headerlink" title="混元 (Mix-ins)"></a>混元 (Mix-ins)</h2><p>既然谈到了通过复制属性来继承，就让我们顺便多说一点，来讨论一下“混元”模式。除了前面说的从一个对象复制，你还可以从任意多数量的对象中复制属性，然后将它们混在一起组成一个新对象。</p><p>实现很简单，只需要遍历传入的每个参数然后复制它们的每个属性：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> arg, prop, child = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (arg = <span class="number">0</span>; arg &lt; <span class="built_in">arguments</span>.length; arg += <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (prop <span class="keyword">in</span> <span class="built_in">arguments</span>[arg]) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">arguments</span>[arg].hasOwnProperty(prop)) &#123;</span><br><span class="line">child[prop] = <span class="built_in">arguments</span>[arg][prop];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们有了一个通用的混元函数，我们可以传递任意数量的对象进去，返回的结果将是一个包含所有传入对象属性的新对象。下面是用法示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cake = mix(</span><br><span class="line">&#123;<span class="attr">eggs</span>: <span class="number">2</span>, <span class="attr">large</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="attr">butter</span>: <span class="number">1</span>, <span class="attr">salted</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">&#123;<span class="attr">flour</span>: <span class="string">"3 cups"</span>&#125;,</span><br><span class="line">&#123;<span class="attr">sugar</span>: <span class="string">"sure!"</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="/images/dmfyms/10.png" alt="/images/dmfyms/10.png"></p><p>图6-10 在Firebug中查看cake对象</p><blockquote><p>如果你习惯了某些将混元作为原生部分的语言，那么你可能期望修改一个或多个父对象时也影响子对象。但在这个实现中这是不会发生的事情。这里我们只是简单地遍历、复制自有属性，并没有与父对象有任何链接。</p></blockquote><h2 id="借用方法"><a href="#借用方法" class="headerlink" title="借用方法"></a>借用方法</h2><p>有时候会有这样的情况：你希望使用某个已存在的对象的一两个方法，你希望能复用它们，但是又真的不希望和那个对象产生继承关系，因为你只希望使用你需要的那一两个方法，而不继承那些你永远用不到的方法。得益于函数的<code>call()</code>和<code>apply()</code>方法，可以通过借用方法模式实现它。在本书中，你其实已经见过这种模式了，甚至在本章<code>extendDeep()</code>的实现中也有用到。</p><p>在<code>JavaScript</code>中函数也是对象，它们有一些有趣的方法，比如<code>call()</code>和<code>apply()</code>。这两个方法的唯一区别是后者接受一个参数数组以传入正在调用的方法，而前者只接受一个一个的参数。你可以使用这两个方法来从已有的对象中借用方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call()示例</span></span><br><span class="line">notmyobj.doStuff.call(myobj, param1, p2, p3);</span><br><span class="line"><span class="comment">// apply()示例</span></span><br><span class="line">notmyobj.doStuff.apply(myobj, [param1, p2, p3]);</span><br></pre></td></tr></table></figure><p>在这个例子中有一个对象<code>myobj</code>，而且<code>notmyobj</code>有一个用得着的方法叫<code>doStuff()</code>。你可以简单地临时借用<code>doStuff()</code>方法，而不用处理继承然后得到一堆<code>myobj</code>中无关的方法。</p><p>你传一个对象和任意的参数，这个被借用的方法会将<code>this</code>绑定到你传递的对象上。简单地说，你的对象会临时假装成另一个对象以使用它的方法。这就像实际上获得了继承但又免除了“继承税”（译注：指不需要的属性和方法）。</p><p><strong>例：从数组借用</strong></p><p>这种模式的一种常见用法是从数组借用方法。</p><p>数组有很多很有用但是一些“类数组”对象（如<code>arguments</code>）不具备的方法。所以<code>arguments</code>可以借用数组的方法，比如<code>slice()</code>。这是一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// returns [2,3]</span></span><br></pre></td></tr></table></figure><p>在这个例子中，有一个空数组被创建了，因为要借用它的方法。也可以使用一种看起来代码更长的方法来做，那就是直接从数组的原型中借用方法，使用<code>Array.prototype.slice.call(...)</code>。这种方法代码更长一些，但是不用创建一个空数组。在这个例子中，有一个空数组被创建了，因为要借用它的方法。也可以使用一种看起来代码更长的方法来做，那就是直接从数组的原型中借用方法，使用<code>Array.prototype.slice.call(...)</code>。这种方法代码更长一些，但是不用创建一个空数组。</p><p><strong>借用并绑定</strong></p><p>当借用方法的时候，不管是通过<code>call()</code>/<code>apply()</code>还是通过简单的赋值，方法中的<code>this</code>指向的对象都是基于调用的表达式来决定的。但是有时候最好的使用方式是将<code>this</code>的值锁定或者提前绑定到一个指定的对象上。</p><p>我们来看一个例子。这是一个对象<code>one</code>，它有一个<code>say()</code>方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = &#123;</span><br><span class="line">name: <span class="string">"object"</span>,</span><br><span class="line">say: <span class="function"><span class="keyword">function</span> (<span class="params">greet</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> greet + <span class="string">", "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">one.say(<span class="string">'hi'</span>); <span class="comment">// "hi, object"</span></span><br></pre></td></tr></table></figure><p>现在另一个对象<code>two</code>没有<code>say()</code>方法，但是它可以从<code>one</code>借用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> two = &#123;</span><br><span class="line">name: <span class="string">"another object"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">one.say.apply(two, [<span class="string">'hello'</span>]); <span class="comment">// "hello, another object"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>say()</code>方法中的<code>this</code>指向了<code>two</code>，<code>this.name</code>是<code>another object</code>。但是如果在某些场景下你将函数赋值给了全局变量或者是将这个函数作为回调，会发生什么？在客户端编程中有非常多的事件和回调，所以这种情况经常发生：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值给变量，this会指向全局对象</span></span><br><span class="line"><span class="keyword">var</span> say = one.say;</span><br><span class="line">say(<span class="string">'hoho'</span>); <span class="comment">// "hoho, undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为回调</span></span><br><span class="line"><span class="keyword">var</span> yetanother = &#123;</span><br><span class="line">name: <span class="string">"Yet another object"</span>,</span><br><span class="line">method: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> callback(<span class="string">'Hola'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">yetanother.method(one.say); <span class="comment">// "Holla, undefined"</span></span><br></pre></td></tr></table></figure><p>在这两种情况中<code>say()</code>中的<code>this</code>都指向了全局对象，所以代码并不像我们想象的那样正常工作。要修复（绑定）一个方法的对象，我们可以用一个简单的函数，像这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">o, m</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m.apply(o, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>bind()</code>函数接受一个对象<code>o</code>和一个方法<code>m</code>，然后把它们绑定在一起，再返回另一个函数。返回的函数通过闭包可以访问到<code>o</code>和<code>m</code>，也就是说，即使在<code>bind()</code>返回之后，内层的函数仍然可以访问到<code>o</code>和<code>m</code>，而<code>o</code>和<code>m</code>会始终指向原来的对象和方法。让我们用<code>bind()</code>来创建一个新函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twosay = bind(two, one.say);</span><br><span class="line">twosay(<span class="string">'yo'</span>); <span class="comment">// "yo, another object"</span></span><br></pre></td></tr></table></figure><p>正如你看到的，尽管<code>twosay()</code>是作为一个全局函数被创建的，但<code>this</code>并没有指向全局对象，而是指向了通过<code>bind()</code>传入的对象<code>two</code>。不论如何调用<code>twosay()</code>，<code>this</code>将始终指向<code>two</code>。</p><p>绑定是奢侈的，你需要付出的代价是<strong>一个额外的闭包</strong>。</p><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p>ECMAScript5在<code>Function.prototype</code>中添加了一个方法叫<code>bind()</code>，使用时和<code>apply()</code>/<code>call()</code>一样简单。所以你可以这样写：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newFunc = obj.someFunc.bind(myobj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>这意味着将<code>someFunc()</code>和<code>myobj</code>绑定了,并且还传入了<code>someFunc()</code>的前三个参数。这也是一个在第4章讨论过的部分应用的例子。</p><p>让我们来看一下当你的程序跑在低于ES5的环境中时如何实现<code>Function.prototype.bind()</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.bind === <span class="string">"undefined"</span>) &#123;</span><br><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">this</span>,</span><br><span class="line">slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fn.apply(thisArg, args.concat(slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现可能看起来有点熟悉，它使用了部分应用，将传入<code>bind()</code>的参数串起来（除了第一个参数），然后在被调用时传给<code>bind()</code>返回的新函数。这是用法示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twosay2 = one.say.bind(two);</span><br><span class="line">twosay2(<span class="string">'Bonjour'</span>); <span class="comment">// "Bonjour, another object"</span></span><br></pre></td></tr></table></figure><p>在这个例子中，除了绑定的对象外，我们没有传任何参数给<code>bind()</code>。下一个例子中，我们来传一个用于部分应用的参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twosay3 = one.say.bind(two, <span class="string">'Enchanté'</span>);</span><br><span class="line">twosay3(); <span class="comment">// "Enchanté, another object"</span></span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在<code>JavaScript</code>中，继承有很多种方案可以选择，在本章中你看到了很多类式继承和现代继承的方案。学习和理解不同的模式是有好处的，因为这可以增强你对这门语言的掌握能力。</p><p>但是，也许在开发过程中继承并不是你经常面对的一个问题。一部分是因为这个问题已经被使用某种方式或者某个你使用的类库解决了，另一部分是因为你不需要在<code>JavaScript</code>中建立很长很复杂的继承链。在静态强类型语言中，继承可能是唯一可以复用代码的方法，但在<code>JavaScript</code>中有更多更简单更优化的方法，包括借用方法、绑定、复制属性、混元等。</p><p>记住，代码复用才是目标，继承只是达成这个目标的一种手段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;摘自：&lt;em&gt;JavaScript patterns&lt;/em&gt; 中译本 - 《JavaScript 模式》第六章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码复用是一个既重要又有趣的话题。如果你面对自己或者别人已经写好的代码，而这些代码又是经过测</summary>
      
    
    
    
    
    <category term="Front-End" scheme="https://12vv.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>【转】 前端性能指标</title>
    <link href="https://12vv.github.io/2021/09/15/performance/"/>
    <id>https://12vv.github.io/2021/09/15/performance/</id>
    <published>2021-09-15T06:00:00.000Z</published>
    <updated>2021-09-16T15:39:42.871Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://mp.weixin.qq.com/s/S7vIJjjApeVxts0JIHzScQ?forceh5=1" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/S7vIJjjApeVxts0JIHzScQ?forceh5=1</a></p><hr><p>前端页面性能是影响用户体验的关键因素，用户打开网站时间太久、白屏时间过长、操作卡顿等，都会导致用户离开页面，严重影响用户的留存率。Google DoubleClick 研究表明：如果一个移动端页面加载时长超过 3 秒，用户就会放弃而离开。BBC 发现网页加载时长每增加 1 秒，用户就会流失 10%。</p><p>那么，如何去计算页面的性能，以便于更好地衡量和改进前端页面性能，这就需要前端性能指标，本文简单介绍每一种性能指标的定义，旨在帮助你理解性能指标，具体优化及详细解读将在后面章节中介绍。</p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>以下分为三个过程来看性能指标：</p><ul><li>文档加载过程</li><li>文档渲染呈现过程</li><li>交互过程</li></ul><h3 id="文档加载过程"><a href="#文档加载过程" class="headerlink" title="文档加载过程"></a>文档加载过程</h3><p>下图是 W3C 的 Navigation Timing 的处理模型，从当前浏览器窗口卸载旧页面开始，到新页面加载完成，整个过程一共被切分为 9 个小块：</p><ul><li>提示卸载旧文档</li><li>重定向/卸载</li><li>应用缓存</li><li>DNS 解析</li><li>TCP 握手</li><li>HTTP 请求处理</li><li>HTTP 响应处理</li><li>DOM 处理</li><li>文档装载完成</li></ul><p>每个小块，取 Unix 时间戳，两两事件之间计算时间差，从而获取中间过程的耗时（精确到毫秒级别）。</p><p><img src="/images/performance/1.png" alt></p><p><img src="/images/performance/2.png" alt></p><p>文档加载过程主要包含以下 几个性能指标：</p><p><strong>TTFB</strong></p><p><code>Time to First Byte</code>，是发出页面请求到接收到应答数据第一个字节所花费的毫秒数，这个时间段内包括<code>DNS</code>查找，<code>TCP</code>连接和<code>SSL</code>连接。</p><p><code>TTFB</code>不仅仅是在服务器上花费的时间，还包括设备请求发送到服务器，再从服务器返回到设备的时间，它计算的是整个延迟的往返时间。</p><p><strong>DCL</strong></p><p><code>DOMContentLoaded</code>，下图更直观的表示下</p><p><img src="/images/performance/3.png" alt></p><p>什么是<code>DOMContentLoaded</code>？</p><p>首先我们先思考一下，如何衡量网页的加载性能？有人认为可以通过计算从空白到完全加载的过程，但其实有些图片等可能加载较慢，但不影响整个页面的正常使用，所以，我们仅仅需要在空白网页看到内容即可。</p><p>所以，我们也可以通过计算这个网页从空白到出现内容所花费的时间，来衡量网页文档的加载性能，那么该如何计算这段时间喃？<strong>当初始的<code>HTML</code>文档被完全加载和解析完成之后，<code>DOMContentLoaded</code>事件被触发，而无需等待样式表、图像和子框架的完全加载。</strong></p><p><strong>L</strong></p><p><code>Load</code>，<code>onLoad</code>事件触发所需时间，<strong>仅在页面所有资源都加载完毕后(比如图片，CSS)，<code>onLoad</code> 事件才被触发。</strong></p><h3 id="文档渲染呈现过程"><a href="#文档渲染呈现过程" class="headerlink" title="文档渲染呈现过程"></a><strong>文档渲染呈现过程</strong></h3><p><strong>FP&amp;FCP</strong></p><ul><li><code>FP (First Paint)</code>：首次绘制，这个指标用于记录页面第一次绘制像素的时间</li><li><code>FCP (First Contentful Paint)</code>：首次内容绘制，这个指标用于记录页面首次绘制文本、图片、非空白<code>Canvas</code>或<code>SVG</code>的时间，也包括带有正在加载中的<code>Web</code>字体的文本</li></ul><p>这两个指标看起来大同小异，但是<code>FCP</code>发生的时间一定大于等于<code>FP</code>，如下图是掘金的指标：</p><p><img src="/images/performance/4.png" alt></p><p><code>FP</code>指的是绘制像素，比如说页面的背景色是灰色的，那么在显示灰色背景时就记录下了<code>FP</code>指标。</p><p>但是此时<code>DOM</code>内容还没开始绘制，可能需要文件下载、解析等过程，只有当<code>DOM</code>内容发生变化才会触发，比如说渲染出了一段文字，此时就会记录下<code>FCP</code>指标</p><p>我们可以把这两个指标认为是和白屏时间相关的指标</p><p><img src="/images/performance/5.png" alt></p><p><strong>FMP</strong></p><p><code>First Meaningful Paint</code>，是指页面的首要内容出现在屏幕上的时间，对于不同的站点，首要内容是不同的，例如：</p><ul><li>博客文章：【大标题 + 首屏文字】是首要内容；</li><li>百度或 Google 的搜索结果页：【首屏的结果】就是首要内容；</li><li>淘宝等购物网站：【图片】会极为重要，因此它是首要内容；</li></ul><p>在 Lighthouse 6.0 中已不推荐使用<code>FMP</code>，建议使用<code>LCP</code>代替</p><p><strong>LCP</strong></p><p><code>Largest Contentful Paint</code>，最大内容绘制，用于记录视窗内最大的元素绘制的时间，该时间会随着页面渲染变化而变化，因为页面中的最大元素在渲染过程中可能会发生改变，另外该指标会在用户第一次交互后停止记录。指标变化如下图：</p><p><img src="/images/performance/6.png" alt></p><p><code>LCP</code>其实能比 <code>FP、FCP、FMP</code> 更能体现一个页面的性能好坏程度，因为这个指标会持续更新。举个例子：当页面出现骨架屏或者 <code>Loading</code> 动画时 <code>FCP</code> 其实已经被记录下来了，但此时页面内容其实并未呈现。</p><p>在 2.5 秒内表示体验优秀。</p><p><img src="/images/performance/7.png" alt></p><p><code>LCP</code> 目前并不会计算所有元素，因为这样会使这个指标变得非常复杂，它现在只关注下面的元素：</p><ul><li><code>&lt;img&gt;</code> 元素</li><li><code>&lt;image&gt;</code>元素内的<code>&lt;svg&gt;</code>元素</li><li><code>&lt;video&gt;</code> 元素</li><li>通过 <code>url()</code> 函数加载背景图片的元素</li><li>包含文本节点或其他内联文本元素子级的块级元素。</li></ul><p><strong>SI</strong></p><p><code>Speed Index</code>，用于度量页面加载过程中内容可视化显示的速度，是 Lighthouse 的六个度量标准之一。</p><p><img src="/images/performance/8.png" alt></p><p>具体如何测量喃？首先在浏览器中捕获页面加载的视频，然后对每 100 毫秒间隔的页面截图计算页面填充的百分比，可以得到这样一个曲线（纵轴是页面可视区域内容填充完成度，横轴是时间）。</p><p><img src="/images/performance/9.png" alt></p><p>上图中的两个都是在 10s 时页面填充完成，但Example 1（左图）在 2s 是就已经填充了 80% 的内容，而 Example 2（右图）在 8s 时才填充 80%。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 SI ：</span><br><span class="line"></span><br><span class="line">Example 1：Speed Index = (80% * 2) +（20% * 10）= 3.6</span><br><span class="line">Example 2：Speed Index = (80% * 8) +（20% * 10）= 8.4</span><br></pre></td></tr></table></figure><p>其中，<code>SI：0-3.4</code> 为最优</p><p><img src="/images/performance/10.png" alt></p><p><strong>FSP</strong></p><p><code>First Screen Paint</code>，即页面从开始加载到<strong>首屏内容全部绘制完成</strong>的时间，用户可以看到首屏的全部内容。</p><h3 id="交互过程"><a href="#交互过程" class="headerlink" title="交互过程"></a><strong>交互过程</strong></h3><p><strong>TTI</strong></p><p><code>Time to Interactive</code>，用于表示网页首次完全达到可交互状态的时间点</p><p>完全达到可交互状态的时间点是从 <code>FCP</code> 开始，在最后一个长任务（Long Task）完成的时间，并且在随后的 5 秒内网络和主线程是空闲的，如下图：</p><p><img src="/images/performance/11.png" alt></p><p>Google 提出了一个 <code>RAIL</code> 模型：对于用户交互（比如点击事件），推荐的响应时间是 100ms 以内。那么为了达成这个目标，推荐在空闲时间里执行任务不超过 50ms（W3C 也有这样的标准规定），这样能在用户无感知的情况下响应用户的交互，否则就会造成延迟感</p><p><img src="/images/performance/12.png" alt></p><p>这是一个很重要的用户体验指标，代表着页面何时真正进入可用的状态。毕竟光内容渲染的快也不够，还要能迅速响应用户的交互。想必大家应该体验过某些网站，虽然内容渲染出来了，但是响应交互很卡顿，只能过一会才能流畅交互的情况。</p><p><strong>FCI</strong></p><p><code>First CPU Idle</code>，页面首可交互时间。</p><p>与 TTI 不同的是：<code>FCI</code> 发生在用户<strong>可以开始</strong>与页面交互时；<code>TTI</code> 发生在用户<strong>完全能够（可持续）</strong>与页面交互时。</p><p><strong>FID</strong></p><p><code>First Input Delay</code>，首次输入延迟，用于记录在 <code>FCP</code> 和 <code>TTI</code> 之间用户首次与页面交互时响应的延迟。就是看用户交互事件触发到页面响应中间耗时多少，如果其中有长任务发生的话那么势必会造成响应时间变长。</p><p><img src="/images/performance/13.png" alt></p><p><img src="/images/performance/14.png" alt></p><p><strong>FPS</strong></p><p><code>Frames Per Second</code>，用于表示每秒可以重新绘制的帧数，是衡量应用流畅度的一个非常重要的指标，<code>60fps</code> (每次绘制 16.7ms)是页面流畅的目标，否则用户便会感觉到页面卡顿。</p><h3 id="核心性能指标"><a href="#核心性能指标" class="headerlink" title="核心性能指标"></a><strong>核心性能指标</strong></h3><p>以上我们学习了 13 个性能指标，但最常用、最关键的是以下四个核心指标：</p><ul><li><strong>白屏时间 (FP &amp; FCP)</strong>：页面空白时间</li><li><strong>首屏时间 (FSP)</strong>：页面可视区域内容以完全呈现时间</li><li><strong>可交互时间 (FCI)</strong>：用户首次可交互时间</li><li><strong>可持续交互时间 (TTI)</strong>：用户首次可完全可持续交互时间</li></ul><h3 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a><strong>总结与思考</strong></h3><p>本文，我们学习了从文档加载到用户交互所涉及的性能指标：</p><ul><li>文档加载过程：<ul><li>TTFB：从请求开始到接收第一字节的时间</li><li>DCL：空白到出现内容所花费的时间</li><li>L：onLoad 事件触发所需时间</li></ul></li><li>渲染呈现过程：<ul><li>FP&amp;FCP：首次绘制（FP，可能是背景色或loading），首次内容绘制时间（FCP）</li><li>FMP：首要内容出现在屏幕上的时间</li><li>LCP：视窗内最大的元素绘制的时</li><li>SI：页面加载过程中内容可视化显示的速度</li><li>FSP：从开始加载到首屏内容全部绘制完成的时间</li></ul></li><li>交互过程：<ul><li>TTI：网页首次完全达到可交互状态的时间点</li><li>FCI：页面首可交互时间</li><li>FID：首次输入延迟</li><li>FPS：每秒可以重新绘制的帧数，用于衡量应用流畅度</li></ul></li></ul><p>其中最重要的是白屏时间（FP&amp;FCP）、首屏时间（FSP）、可交互时间（FCI）、可持续交互时间（TTI）。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a><strong>参考链接</strong></h3><ol><li>MDN</li><li>Web 性能指标：<a href="https://juejin.cn/post/6844904153869713416" target="_blank" rel="noopener">https://juejin.cn/post/6844904153869713416</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/S7vIJjjApeVxts0JIHzScQ?forceh5=1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/S7vI</summary>
      
    
    
    
    
    <category term="Front-End" scheme="https://12vv.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>JS 模块化</title>
    <link href="https://12vv.github.io/2021/08/20/js-module/"/>
    <id>https://12vv.github.io/2021/08/20/js-module/</id>
    <published>2021-08-20T06:00:00.000Z</published>
    <updated>2021-08-23T22:06:22.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模块化的演变"><a href="#模块化的演变" class="headerlink" title="模块化的演变"></a>模块化的演变</h2><p>在没有模块化的概念之前，代码量也不大的时候，可以直接将<code>JavaScript</code>代码写在<code>html</code>的<code>&lt;script&gt;</code>标签中，如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>当代码量变多了，也可以在<code>html</code>引入外部<code>js</code>脚本，如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"js/index.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当业务变得复杂，人们开始<strong>根据页面</strong>来引入脚本，即一个页面就引入包含此逻辑的脚本，公用的脚本可以每个页面都引入。但是，当这个公用的脚本过于复杂，有多个处理逻辑，如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... many other functions</span></span><br></pre></td></tr></table></figure><p>有可能<code>页面1</code>只需要<code>fn1,fn2</code>等等很多函数，<code>页面2</code>却只需要<code>fn1</code>，却都要引入整个脚本，这就不太合理了。</p><p>那么，<strong>按照功能</strong>来分如何？我们在<code>a.js, b.js, c.js</code>分别处理<code>a, b, c</code>如下，然后引入该页面的逻辑<code>index.js</code>，简单起见这里<code>index.js</code>就简单的把<code>a, b, c</code>输出。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;link rel="stylesheet" type="text/css" href="styles.css"&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello there!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"b.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"c.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reverse();</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> b = a.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">var</span> c = b.join(<span class="string">'-'</span>);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(moduleA.a);  <span class="comment">// [3, 2, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(moduleB.b);  <span class="comment">// [3, 2, 1, 4, 5, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(moduleC.c);  <span class="comment">// 3-2-1-4-5-6</span></span><br></pre></td></tr></table></figure><p>这种写法存在的问题：</p><ul><li><strong>顺序问题</strong>：在<code>html</code>的引入脚本的时候，顺序必须要按照模块的逻辑，否则就会报错，这是因为解析<code>html</code>会造成阻塞，解析完一个脚本再进行下一个，假设我们把<code>index.js</code>先引入了，这个时候<code>a,b,c</code>都还没有定义。</li><li><strong>作用域问题</strong>：可以看到这些文件是公用一个作用域的，在单独脚本暴露出来的变量，实际上都存在于<strong>全局</strong>作用域。容易发生变量覆盖等问题。</li></ul><p>这里就引出了模块化需要解决的问题：加载顺序，污染的全局变量。</p><p>为了避免全局变量的污染，可以通过闭包来尝试解决，将需要的变量通过返回值暴露出去即可。</p><p>下面通过立即执行函数把之前例子改写如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> moduleA = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reverse();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: a</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// moduleA = &#123;a : a&#125;;</span></span><br></pre></td></tr></table></figure><p>该模块是暴露在全局的，可以<code>a</code>变量是模块局部的，在b中要使用可通过<code>moduleA.a</code>，下面通过注入的方式避免了在全局下寻找<code>moduleA</code>。</p><blockquote><p>这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p></blockquote><p>类似于<code>jQuery</code>：<code>;(function($){//do something}(jQuery))</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="comment">// 要使用 moduleA 中的变量，将 moduleA 注入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moduleB = (<span class="function"><span class="keyword">function</span>(<span class="params">moduleA</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = moduleA.a.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    b: b</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(moduleA);</span><br></pre></td></tr></table></figure><p>在<code>c.js</code>中同理，通过注入<code>moduleB</code>来使用<code>moduleB</code>的变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c.js</span></span><br><span class="line"><span class="keyword">var</span> moduleC = (<span class="function"><span class="keyword">function</span>(<span class="params">moduleB</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = moduleB.b.join(<span class="string">'-'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    c: c</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(moduleB);</span><br></pre></td></tr></table></figure><p>最后，<code>index.js</code>依赖于以上模块。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">moduleA, moduleB, moduleC</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(moduleA.a);</span><br><span class="line">  <span class="built_in">console</span>.log(moduleB.b);</span><br><span class="line">  <span class="built_in">console</span>.log(moduleC.c);</span><br><span class="line">&#125;)(moduleA, moduleB, moduleC);</span><br></pre></td></tr></table></figure><p>但是该方法依然要求保证引入脚本的顺序。</p><blockquote><p>开发者通过实践，形成了一种插件化模式，很多也是通过立即执行函数来实现的。插件能够给用户提供一些可配置项，让用户通过配置项实现不同的功能。</p></blockquote><h2 id="模块化解决方案"><a href="#模块化解决方案" class="headerlink" title="模块化解决方案"></a>模块化解决方案</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p><code>CommonJS</code> 是来源于 <code>NodeJS</code> 的一种规范，需要<code>node</code>环境。</p><p>并且由于它是同步加载的，通过<code>require</code>引用，必须加载完成后才会执行下面的代码(阻塞)，这样就很不适合浏览器环境。</p><blockquote><p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p></blockquote><p>这也是之后引入<code>异步模块定义(Asynchronous Module Definition, AMD)</code>的原因。</p><p>使用 <code>CommonJS</code> 改写上面的例子，此时<code>index.html</code>只需要引入<code>index.js</code>即可。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [common JS] a.js</span></span><br><span class="line"><span class="keyword">var</span> a = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reverse();</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  a</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [common JS] b.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> moduleA.a.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  b</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [common JS] c.js</span></span><br><span class="line"><span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> moduleB.b.join(<span class="string">'-'</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  c</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [common JS] index.js</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="keyword">var</span> moduleB = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="keyword">var</span> moduleC = <span class="built_in">require</span>(<span class="string">'./c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(moduleA.a);</span><br><span class="line"><span class="built_in">console</span>.log(moduleB.b);</span><br><span class="line"><span class="built_in">console</span>.log(moduleC.c);</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>require</code>会创建一个模块的实例，并且有缓存机制，</p><blockquote><p><code>CommonJS</code>一个模块对应一个脚本文件，<code>require</code> 命令每次加载一个模块就会执行整个脚本，然后生成一个对象。这个对象一旦生成，以后再次执行相同的 <code>require</code> 命令都会直接到缓存中取值。</p></blockquote><p>引用模块脚本进来其实是一个立即执行函数，例如，对于下面的 <code>JS</code> 模块文件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> modulex = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// do something;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = modulex;</span><br></pre></td></tr></table></figure><p>引入时会被<code>node.js</code>包装成如下形式，这也是为什么我们能够使用<code>exports, require, module</code>的原因。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> modulex = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// do something;</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">module</span>.exports = modulex;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p><code>异步模块定义(Asynchronous Module Definition, AMD)</code>是是在浏览器环境下出现的模块化解决方案，异步加载模块，并且是前置依赖，即依赖加载完毕后才会执行最后一个参数的回调函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Calling define with module ID, dependency array, and factory function</span></span><br><span class="line">define(<span class="string">'myModule'</span>, [<span class="string">'dep1'</span>, <span class="string">'dep2'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">dep1, dep2</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Define the module value by returning a value.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>AMD</code>基于<code>require.js</code>，主要解决的问题是：</p><ul><li>实现<code>js</code>文件的异步加载，避免网页失去响应；</li><li>管理模块之间的依赖性，便于代码的编写和维护。</li></ul><p>使用<code>AMD</code>改写上面的例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [AMD] a.js</span></span><br><span class="line">define(<span class="string">'moduleA'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reverse();</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a: a</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [AMD] b.js</span></span><br><span class="line">define(<span class="string">'moduleB'</span>, [<span class="string">'moduleA'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleA</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = moduleA.a.concat([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    b: b</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [AMD] c.js</span></span><br><span class="line">define(<span class="string">'moduleC'</span>, [<span class="string">'moduleB'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleB</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = moduleB.b.join(<span class="string">'-'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    c: c</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要在入口文件配置依赖的脚本的路径，在此例中是<code>index.js</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [AMD] index.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要在入口文件配置依赖的路径</span></span><br><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">  path: &#123;</span><br><span class="line">    moduleA: <span class="string">'./a'</span>,</span><br><span class="line">    moduleB: <span class="string">'./b'</span>,</span><br><span class="line">    moduleC: <span class="string">'./c'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'moduleA'</span>, <span class="string">'moduleB'</span>, <span class="string">'moduleC'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">moduleA, moduleB, moduleC</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(moduleA.a);</span><br><span class="line">  <span class="built_in">console</span>.log(moduleB.b);</span><br><span class="line">  <span class="built_in">console</span>.log(moduleC.c);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>AMD</code>解决了模块依赖问题，规范化了输入输出。</p><h3 id="CMD-SeaJS"><a href="#CMD-SeaJS" class="headerlink" title="CMD (SeaJS)"></a>CMD (SeaJS)</h3><p><code>Common Module Definition</code>，即通用模块定义。<code>CMD</code> 是 <code>SeaJS</code> 在推广过程中对模块定义的规范化产出。</p><p><code>CMD</code>规范和<code>AMD</code>类似，都主要运行于浏览器端，写法上看起来也很类似。主要是区别在于<strong>模块初始化时机</strong></p><ul><li><strong>AMD是依赖前置：只要模块作为依赖时，就会加载并初始化，加载完后执行回调</strong></li><li><strong>CMD是依赖就近：模块作为依赖且被引用时才会初始化，否则只会加载。</strong></li><li><code>AMD</code> 的 <code>API</code> 默认是一个当多个用，<code>CMD</code> 严格的区分推崇职责单一。例如，<code>AMD</code> 里 <code>require</code> 分全局的和局部的。CMD里面没有全局的 <code>require</code>，提供 <code>seajs.use()</code> 来实现模块系统的加载启动。<code>CMD</code> 里每个 <code>API</code> 都简单纯粹。</li></ul><h3 id="UMD规范"><a href="#UMD规范" class="headerlink" title="UMD规范"></a>UMD规范</h3><p>集结了 <code>CommonJs, CMD, AMD</code> 的规范于一身，通过运行时或者编译时让同一个代码模块在使用 <code>CommonJs, CMD, AMD</code>的项目中运行。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UMD 简单实现</span></span><br><span class="line">(<span class="function">(<span class="params">global, factory</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//如果 当前的上下文有 defin e函数，说明处于AMD 环境下</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        define([<span class="string">"moduleA"</span>], factory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;<span class="comment">// CommonJS</span></span><br><span class="line">        <span class="keyword">let</span> moduleA = <span class="built_in">require</span>(<span class="string">"moduleA"</span>)</span><br><span class="line">        modules.exports = factory(moduleA)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        global.moduleA = factory(global.moduleA) <span class="comment">//直接挂载成 windows 全局变量 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="keyword">this</span>, (moduleA) =&gt; &#123;</span><br><span class="line">    <span class="comment">//本模块的定义</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h3><p><code>import</code>命令用于输入其他模块提供的功能，<code>export</code>命令用于规定模块的对外接口。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lib.js</span></span><br><span class="line"><span class="comment">//导出常量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sqrt = <span class="built_in">Math</span>.sqrt;</span><br><span class="line"><span class="comment">//导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">diag</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(square(x) + square(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; square, diag &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(square(<span class="number">11</span>)); <span class="comment">// 121</span></span><br><span class="line"><span class="built_in">console</span>.log(diag(<span class="number">4</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>ES6 Module 和 CommonJS 对比</strong></p><ul><li><code>ES6 Module</code>是<strong>静态化</strong>的，在编译时确定模块的依赖关系。<code>CommonJS</code>和<code>AMD</code>只能在运行时确定。</li><li><code>CommonJS</code>模块输出的是一个值的<strong>浅拷贝</strong>，<code>ES6</code>输出的是值的引用</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [CommonJS]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  counter: counter,</span><br><span class="line">  incCounter: incCounter,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).counter;</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">'./lib'</span>).incCounter;</span><br><span class="line"><span class="built_in">console</span>.log(counter);  <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 上面代码说明，**counter** 输出以后，**lib.js** 模块内部的变化就影响不到 **counter** 了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----------------------------------------------------------------------------//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//common_lib.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    obj.counter ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    counter : <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.obj = obj;</span><br><span class="line">exports.incCounter = incCounter</span><br><span class="line"></span><br><span class="line"><span class="comment">//common_main.js</span></span><br><span class="line"><span class="keyword">let</span> lib = <span class="built_in">require</span>(<span class="string">'./common_lib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(lib.obj);   <span class="comment">//3</span></span><br><span class="line">lib.incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(lib.obj);   <span class="comment">//4</span></span><br><span class="line"><span class="comment">// 可以理解为对 lib 是浅拷贝，所以能够更改引用类型的 obj</span></span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [ES6 Module]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">//3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">//4</span></span><br><span class="line"><span class="comment">// **incCounter** 方法调用，能够修改**counter**, 说明 **ES6 module** 导出的是**变量的引用**，而不是值拷贝。</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.bilibili.com/video/BV1K54y1S7zx" target="_blank" rel="noopener">JavaScript模块化全面解析</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">Javascript模块化编程</a></li><li><a href="https://segmentfault.com/a/1190000018725060" target="_blank" rel="noopener">JS模块化——CommonJS AMD CMD UMD ES6 Module 比较</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;模块化的演变&quot;&gt;&lt;a href=&quot;#模块化的演变&quot; class=&quot;headerlink&quot; title=&quot;模块化的演变&quot;&gt;&lt;/a&gt;模块化的演变&lt;/h2&gt;&lt;p&gt;在没有模块化的概念之前，代码量也不大的时候，可以直接将&lt;code&gt;JavaScript&lt;/code&gt;代码写在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>移动端适配方案</title>
    <link href="https://12vv.github.io/2021/08/11/device/"/>
    <id>https://12vv.github.io/2021/08/11/device/</id>
    <published>2021-08-11T06:00:00.000Z</published>
    <updated>2021-09-16T15:39:28.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h2><p><strong>设备像素(device pixel, dp)</strong></p><p>又称为物理像素。指设备能控制显示的最小物理单位，意指显示器上一个个的点，由工厂生产决定，它上面设备像素点就固定不变了。</p><p>单位 <code>pt</code>，在<code>CSS</code>中是真正的绝对单位。</p><p><strong>CSS像素(css pixel, px)</strong></p><p>在不考虑屏幕缩放等情况下，CSS像素等同于逻辑像素。</p><p>CSS 样式代码中使用的<strong>逻辑像素</strong>。又叫<strong>设备独立像素</strong>。</p><p>我们给文字设置<code>font-size: 12px</code> 时，屏幕不能按照物理像素和<code>CSS</code>像素<code>1:1</code>的比例来绘制，否则文字会小到看不见。换个分辨率低的设备，文字大小又会变大很多。</p><p>这时候设备厂商发明了一个<strong>逻辑像素</strong>(设备独立像素)的概念。比如 <code>IPhone 12 Pro Max</code> 水平方向的逻辑像素是<code>428px</code>，那么在默认情况下，当我们给页面元素设置样式 <code>width: 428px</code> 时，在<code>IPhone 12 Pro Max</code> 正好能水平撑满整个屏幕。</p><p>在不同设备逻辑像素相同则视觉尺寸相同，每一个逻辑像素包含物理像素点不一样多，包含越多物理像素点越多则越清晰。</p><p><img src="/images/device/3.png" alt="Untitled"></p><p><strong>屏幕像素密度</strong></p><p><code>屏幕像素密度 (Pibel Per Inch)</code> 简称<code>ppi</code>，表示每<strong>英寸(屏幕对角线长度)</strong>物理像素。</p><p>对于 iPhone12 mini，5.4英寸(屏幕对角线长度)，分辨率为1080 x 2340，则</p><script type="math/tex; mode=display">ppi = Math.sqrt(10801080 + 23402340) / 5.4 = 476</script><p><strong>设备像素比</strong></p><p>缩写简称<code>dpr</code>。</p><p>设备像素比 = 设备像素 / css像素（垂直方向或水平方向）</p><p>可以通过JS来获取：<code>window.devicePixelRatio</code></p><p><img src="/images/device/1.png" alt="Untitled"></p><p><img src="/images/device/2.png" width="50%" height="50%"></p><h3 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h3><p><strong>PX</strong></p><p>在屏幕分辨率固定，不考虑屏幕缩放的情况下，<code>px</code>是绝对的，不会随着浏览器视口变化而变化。比如，电脑屏幕分辨率调为<code>1440*900</code>时，<code>css</code>里设置的<code>1px</code>实际的物理尺寸就是屏幕宽度的<code>1/1440</code>。</p><p><strong>em</strong></p><p>默认字体大小的倍数。</p><p>比如，给元素设置<code>font-size: 2em</code>，这里的默认字体大小实际上是继承自父亲的大小，<code>font-size: 2em</code>表示当前元素字体大小是父亲的<code>2</code>倍。</p><p>当给元素设置<code>width: 2em</code>，这里的默认字体大小是该<strong>元素自身</strong>的实际字体大小。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>em 演示<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello 饥人谷<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">      body&#123;</span></span><br><span class="line"><span class="undefined">        font-size: 2em;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      p &#123;</span></span><br><span class="line"><span class="undefined">        font-size: 2em;</span></span><br><span class="line"><span class="undefined">        width: 2em;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上例示，<code>html</code>默认是<code>16px</code>，<code>body</code>是<code>2em</code>，其父元素即为<code>html</code>，所以是<code>16px</code>的<code>2</code>倍<code>32px</code>， <code>article</code>是<code>32px</code>，那么<code>p</code>的<code>font-size</code>是<code>article</code>的<code>2</code>倍<code>64px</code>，<code>p</code>的宽度<code>width</code>是它自身字体的<code>2</code>倍，即<code>64px * 2 = 128px</code>。</p><p><strong>rem</strong></p><p>以根元素字体大小为基准。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;<span class="attribute">font-size</span>: <span class="number">12px</span>;&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">font-size</span>: <span class="number">2rem</span>; &#125; <span class="comment">/* 2 × 12px = 24px */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-size</span>: <span class="number">1.5rem</span>;&#125; <span class="comment">/* 1.5 × 12px = 18px */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;<span class="attribute">width</span>: <span class="number">20rem</span>;&#125; <span class="comment">/* 20 * 12px = 240px*/</span></span><br></pre></td></tr></table></figure><p><strong>百分比%</strong></p><p>对不同属性有不同的含义。</p><ul><li><code>font-size: 200%</code> 同<code>font-size: 2em</code>，表示字体大小是默认（继承自父亲）字体大小的2倍。</li><li><code>line-height: 200%</code> 表示行高是<strong>自己字体大小</strong>的<code>2</code>倍。</li><li><code>width: 100%</code>在<strong>标准盒模型</strong>下表示自己<code>content</code>的宽度等于父亲<code>content</code>的宽度，在<strong>IE盒模型</strong>下表示自己<code>content+padding+border</code>的宽度等于父亲<code>content</code>的宽度。</li></ul><p><strong>vw, vh</strong></p><p>代表当前浏览器视口宽度/高度的百分之几。</p><p>比如，<code>1vw</code>代表浏览器视口宽度的<code>1%</code>；<code>100vh</code>代表浏览器视口高度的<code>100%</code>。</p><h2 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h2><p>一种适配方案是对不同屏幕尺寸设置根元素<code>html</code>的<code>rem</code>。</p><p>可以通过<code>JavaScript</code>读取屏幕宽度，然后根据宽度计算出对应的尺寸并设置根元素的<code>font-size</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> oHtml = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> width = oHtml.clientWidth;</span><br><span class="line"><span class="comment">// 320px的屏幕基准像素为12px</span></span><br><span class="line">oHtml.style.fontSize = <span class="number">12</span> * (width / <span class="number">320</span>) + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure><p>或者通过媒体查询根据屏幕宽度适配。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">375px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">14.0625px</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">360px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">13.5px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">320px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rem有其局限性。</p><blockquote><p><code>iOS</code>与<code>Android</code>平台的适配方式背后隐藏的设计哲学是这样的：阅读文字时，可读性较好的文字字号行距等绝对尺寸数值组合与文字所在媒介的绝对尺寸关系不大。（可以这样简单理解：A4大小的报纸和A3大小甚至更大的报纸，舒适的阅读字号绝对尺寸是一样的，因为他们都需要拿在手里阅读，在手机也是上同理）；在看图片视频时，图片、视频的比例应该是固定的，不应该出现拉伸变形的情况。而<code>rem</code>用在字号时，使字号在不同屏幕上的绝对尺寸不一致，违背了设计哲学。</p></blockquote><h2 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h2><p>在移动端，默认的情况下，布局视口的宽度是要远远大于浏览器的宽度的。</p><p>浏览器厂商为了让用户在小屏幕下网页也能够显示地很好，所以把布局视口宽度设置地很大，一般在<code>768px-1024px</code>之间，最常见的宽度是<code>980px</code>。</p><p>如下图例子，在<code>iPhone6(375*667)</code>下，浏览器宽度只有<code>375px</code>，但是<code>body</code>的宽度却是<code>980px</code>。</p><p><img src="/images/device/4.png" alt></p><p>这个宽度可以通过<code>document.documentElement.clientWidth</code>得到。</p><p>为何要这样设计呢？</p><p>在没有做任何移动端适配的时候，浏览器希望在移动端也尽可能合适的显示网页，如果没有设置比较大的布局适口宽度，移动端的宽度比 PC 端是小很多的，很容易造成布局崩溃。</p><h3 id="meta-标签"><a href="#meta-标签" class="headerlink" title="meta 标签"></a>meta 标签</h3><p>做移动端适配，总是要加上这行代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>意思是让页面的布局视口的宽度等于视觉视口的宽度，此时页面元素会以设备逻辑像素宽度做为文档宽度进行布局。</p><p>一般还会禁止用户缩放</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no;"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://mp.weixin.qq.com/s/W0KtXtLYUskJ48NOQUPHUg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/W0KtXtLYUskJ48NOQUPHUg</a></li><li><a href="https://imweb.io/topic/5a523cc0a192c3b460fce3a5" target="_blank" rel="noopener">https://imweb.io/topic/5a523cc0a192c3b460fce3a5</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专有名词&quot;&gt;&lt;a href=&quot;#专有名词&quot; class=&quot;headerlink&quot; title=&quot;专有名词&quot;&gt;&lt;/a&gt;专有名词&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;设备像素(device pixel, dp)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又称为物理像素。指设备能控制显</summary>
      
    
    
    
    
    <category term="Front-End" scheme="https://12vv.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>IIFE-立即调用函数表达式</title>
    <link href="https://12vv.github.io/2021/07/01/IIFE/"/>
    <id>https://12vv.github.io/2021/07/01/IIFE/</id>
    <published>2021-07-01T06:00:00.000Z</published>
    <updated>2021-09-16T15:22:04.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>立即调用的匿名函数又被称作立即调用的函数表达式<code>(IIFE, Immediately Invoked Function Expression)</code>。</p><p>它类似于函数声明，但由于被包含在括号中，所以会被解释为<code>函数表达式</code>。</p><a id="more"></a><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am IIFE"</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// w3c 标准建议使用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am IIFE"</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 箭头函数写法</span></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am IIFE"</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>如果以<code>function</code>开头，则会被识别为函数声明，<strong>函数声明是不能被被执行符号<code>()</code>执行的！</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>); <span class="comment">// Uncaught SyntaxError: </span></span><br><span class="line"><span class="comment">// Function statements require a function name</span></span><br><span class="line">&#125;();                  <span class="comment">// 这个报错是因为函数声明一定要有函数名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>); <span class="comment">// Uncaught SyntaxError: Unexpected token ')'</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>只要是函数表达式，就可以加执行符号达到立即执行的效果了。</p><p>也可以加上一元操作符将函数转成表达式 (不推荐使用)。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上操作符，编译器不再认为这是一个函数声明</span></span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);<span class="comment">// 1</span></span><br><span class="line">&#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);<span class="comment">// 2</span></span><br><span class="line">&#125;();</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);<span class="comment">// 3</span></span><br><span class="line">&#125;()</span><br><span class="line">,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);<span class="comment">// 4</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p>很多人习惯在前面加<code>;</code>，就是为了避免两个立即执行函数连在一起时发生如下错误：以下代码只能输出一个<code>a</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: (intermediate value)(...) is not a function</span></span><br></pre></td></tr></table></figure><p>再补充一个奇怪的情况：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里不会报错，也不会输出，实际上这种写法会被解释成<strong>一个函数声明，还有一个无意义的表达式</strong>。也就是下面的样子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个表达式</span></span><br><span class="line">(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p><strong>关于非匿名自执行函数</strong></p><p>注意：立即执行函数也是可以加名字的，但是要注意，<strong>函数名<code>只读</code></strong>。看下面这个例子</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>在非严格模式下会输出<code>[Function b]</code>，在严格模式下会报错！<code>Uncaught TypeError: Assignment to constant variable.</code></p><p>原因就在于匿名函数属于表达式的范畴，如果添加了名字，遵从<strong>具名函数表达式</strong>的规范。</p><p>函数表达式中函数的识别名是不需要的，有名称的函数表达式，就是<code>具名函数表达式 (Named function expressions, NFE)</code>，其函数的识别名，它的作用域是<strong>只在函数的主体内部</strong>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">b = <span class="number">10</span>;                 <span class="comment">// 严格模式下改行报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(b);         <span class="comment">// [Function b]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b);  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="进行初始化"><a href="#进行初始化" class="headerlink" title="进行初始化"></a>进行初始化</h3><p>在<code>ES6</code>的<code>let</code>和<code>const</code>，可以用立即执行函数来模拟块级作用域，避免全局变量污染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo; <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure><p>类似的，有一些操作需要在页面加载完成立即执行，比如绑定事件、创建对象等，也需要一些临时的变量，但是之后不会再用到。这时候使用立即执行函数，将这些初始化代码包裹在其局部作用域中，就是个很好的方案。</p><p>下面这个例子在初始化时绑定监听事件，<code>count</code>变量不会被泄漏出去，而且点击事件也能正常运作。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>, count++);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure><h3 id="模块化封装"><a href="#模块化封装" class="headerlink" title="模块化封装"></a>模块化封装</h3><p>使用一个立即执行函数创建的闭包，实现对象字面量创建对象的私有成员。以此来封装模块，暴露的接口成为公有方法以供调用，私有成员外部无法取得。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 私有成员</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"my, oh my"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现公有部分</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">myobj.getName(); <span class="comment">// "my, oh my"</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a>经典题</h3><p>下面这道经典题目</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上很多解释是说是因为事件队列的原因，说因为回调函数被放到事件队列中，<code>for</code>循环执行完毕<code>i</code>的值已经变成了<code>5</code>，再执行<code>5</code>个<code>console.log(i)</code>所以会输出<code>5</code>个<code>5</code>。</p><p>开始我看到这种解释有些困惑，为什么换成<code>let</code>就能解决呢？如果说是因为事件循环的原因，那换成<code>let</code>，循环完毕<code>i</code>也变成<code>5</code>了。</p><p>之后我补充了作用域，作用域链，执行上下文等知识，才了解到这种现象是由于作用域造成的。</p><p>之所以使用<code>let</code>就可以得到期望结果，是由于<code>let</code>的块级作用域，每一轮循环都会有一个新的词法作作用域环境保存每一轮的<code>i</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">blockLexicalEnvironment = &#123;</span><br><span class="line">  i: <span class="number">0</span>,</span><br><span class="line">  outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br><span class="line">blockLexicalEnvironment = &#123;</span><br><span class="line">  i: 1,</span><br><span class="line">  outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br><span class="line">blockLexicalEnvironment = &#123;</span><br><span class="line">  i: 2,</span><br><span class="line">  outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>之后执行<code>console.log(i)</code>，由于当前作用域没有<code>i</code>，所以沿着<strong>作用域链</strong>找，即找到了他上一层的块级词法环境中的<code>i</code>。</p><p>所以使用这里使用立即执行函数也是同样的原理。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的<br>作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p></blockquote><h3 id="立即执行函数的递归"><a href="#立即执行函数的递归" class="headerlink" title="立即执行函数的递归"></a>立即执行函数的递归</h3><p>立即执行函数是如果不加名字，又想要自身递归调用怎么办呢？可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments/callee" target="_blank" rel="noopener">arguments.callee</a>，已在ES5严格模式中被废弃，了解原因可以看<a href="https://stackoverflow.com/questions/103598/why-was-the-arguments-callee-caller-property-deprecated-in-javascript" target="_blank" rel="noopener">这里</a>。</p><blockquote><p><code>callee</code>是<code>arguments</code>对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> init = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(init);    <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure><p>当然，可以使用<strong>具名函数</strong>直接调用，如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> init = (<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * a(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(init);    <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure><h3 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h3><p>匿名函数属于函数表达式，创建执行上下文时不会被提升。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);       <span class="comment">// 正常输出</span></span><br><span class="line"><span class="built_in">console</span>.log(sayName);   <span class="comment">// Uncaught ReferenceError: sayName is not defined</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;)(<span class="string">'Millzie'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53" target="_blank" rel="noopener">https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53</a></p><p><a href="https://stackoverflow.com/questions/103598/why-was-the-arguments-callee-caller-property-deprecated-in-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/103598/why-was-the-arguments-callee-caller-property-deprecated-in-javascript</a></p><p>Kyle Simpson. 2014. You Don’t Know JS: Scope &amp; Closures (1st. ed.). O’Reilly Media, Inc.</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;立即调用的匿名函数又被称作立即调用的函数表达式&lt;code&gt;(IIFE, Immediately Invoked Function Expression)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它类似于函数声明，但由于被包含在括号中，所以会被解释为&lt;code&gt;函数表达式&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Front-End" scheme="https://12vv.github.io/tags/Front-End/"/>
    
  </entry>
  
  <entry>
    <title>Optics</title>
    <link href="https://12vv.github.io/2020/02/29/stcg05/"/>
    <id>https://12vv.github.io/2020/02/29/stcg05/</id>
    <published>2020-02-29T07:00:00.000Z</published>
    <updated>2021-03-14T18:59:53.342Z</updated>
    
    <content type="html"><![CDATA[<h3 id="经验模型"><a href="#经验模型" class="headerlink" title="经验模型"></a>经验模型</h3><p>经典光照模型属于经验模型，单独计算<code>环境光(ambient)</code>，<code>漫反射光(diffuse)</code>和<code>镜面光(specular)</code>，再进行叠加。</p><p><img src="/images/stcg/05lightmod.jpg" alt></p><ul><li><code>环境光(ambient)</code>：不来自于特定光源，不依赖于观察方向和场景中其他的任意光。</li><li><code>漫反射光(diffuse)</code>：均匀的散射在表面各个方向，独立于观察方向，依赖于表面法向量和光源方向，也和表面的颜色有关。</li><li><code>镜面光(specular)</code>：表面反射的高光，与表面材质有关，依赖于表面法向量和光源方向和观察方向，颜色可或不可结合表面颜色。<code>光泽度(shininess)</code>越高，高光越趋近于一个亮点。</li></ul><p>例如<code>1975</code>年<code>Phong</code>提出的<code>Phong反射模型(Phong Reflection Model)</code>:</p><script type="math/tex; mode=display">I_{Phong} = k_aI_a + k_d(n \cdot l)I_d + k_s(r \cdot v)^aI_s</script><h3 id="基于物理的分析模型"><a href="#基于物理的分析模型" class="headerlink" title="基于物理的分析模型"></a>基于物理的分析模型</h3><p>经典光照模型没有遵循<code>能量守恒定律(Energy Conservation)</code>: 出射光线的能量永远不能超过入射光线的能量（发光面除外）。而基于微平面理论的物理分析模型是能量守恒的。这项理论认为，达到微观尺度之后任何平面都可以用被称为<code>微平面(Microfacets)</code>的细小镜面来进行描绘。根据平面粗糙程度的不同，这些细小镜面的取向排列可以相当不一致。如下图所示，不同的微表面分布造成不同的微表面上发现的分布，以此可以模拟不同的材质。</p><p><img src="/images/stcg/05micro.jpg" alt="不同的微表面分布"></p><p>产生的效果就是：一个平面越是粗糙，这个平面上的微平面的排列就越混乱。这些微小镜面这样无序取向排列的影响就是，当我们特指镜面光/镜面反射时，入射光线更趋向于向完全不同的方向<code>发散(Scatter)</code>开来，进而产生出分布范围更广泛的镜面反射。而与之相反的是，对于一个光滑的平面，光线大体上会更趋向于向同一个方向反射，造成更小更锐利的反射。</p><p><img src="/images/stcg/surface.png" alt="粗糙和光滑平面的反射"></p><p>为了遵守能量守恒定律，当一束光线接触到一个表面，分成一个折射部分和一个反射部分。反射部分就是会直接反射开来而不会进入平面的那部分光线，这就是我们所说的镜面光照。而折射部分就是余下的会进入表面并被吸收的那部分光线，这也就是我们所说的漫反射光照。</p><h3 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h3><p>以下是一些专有名词的解释。</p><p><img src="/images/stcg/terminology.jpg" alt="Terminology"></p><h4 id="Radiant-Flux"><a href="#Radiant-Flux" class="headerlink" title="Radiant Flux"></a>Radiant Flux</h4><p>辐射通量是光源发出的单位时间总能量的量度，$\Phi = \frac{dQ}{dt} $ 单位是瓦特。</p><p>下图是日光的光谱分布，<code>辐射通量(radiant Flux)</code>是函数的面积(确切地说，该面积是<code>光通量(luminous flux)</code>，因为图表将波长限制在人类可见光范围内)。</p><p><img src="/images/stcg/dayavgspectrum.jpg" alt="Daylight spectral distribution"></p><p>注意：一般在计算机图形中不实用波长强度而是使用三原色编码，即<code>RGB</code>，作为辐射通量表示的简化。虽然有一些信息上的损失，但是对于视觉效果的影响几乎可以忽略。</p><h4 id="Solid-angle"><a href="#Solid-angle" class="headerlink" title="Solid angle"></a>Solid angle</h4><p><code>立体角(solid angle)</code>是一种测量物体在观察者看来有多大的方法。 下图展示将物体的轮廓投射到一个以我们观察点为中心的单位球体的表面上。 我们得到的形状的<code>面积</code>是立体角。下图中单位球面上的区域<code>w</code>即为浅蓝色多边形的投影的立体角。</p><p><img src="/images/stcg/solid_angle.png" alt="Solid angle"></p><p>下图是角和立体角的类比。</p><p><img src="/images/stcg/solid2.jpg" alt="Angle and solid angle"></p><h4 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h4><p><code>辐射强度(radiant Intensity)</code>是在单位球面上，一个光源向每单位立体角的<code>通量(flow of energy)</code>。 如果你有一个向各个方向发射的光源，那么有多少光(通量)实际上是朝着一个特定的方向发射的？ 强度是一种衡量的方法，描述沿着一个方向通过一个立体角的通量。 描述它的公式是$I =\frac{d\Phi}{ d\omega}$，其中$\Phi$是辐射通量，$\omega$是立体角。</p><p><img src="/images/stcg/intensity.png" alt="Light intensity"></p><h4 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h4><p>所有投射到某单位面积上的光线的总和，而这个和就称为辐射照度或者<code>辐照度(Irradiance)</code>。</p><p><img src="/images/stcg/irradiance.jpg" alt="Irradiance on a Surface"></p><h4 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h4><p><code>radiance</code>辐射率表示一个拥有辐射强度<code>Φ</code>的光源在单位面积<code>A</code>，单位立体角<code>ω</code>上的辐射出的总能量，辐射率方程如下。(与<code>irradiance</code>不同的是它考虑特定方向的光。)</p><script type="math/tex; mode=display">L = \frac{dI}{dA cos\theta} = \frac{d\phi^2}{ dA d\omega cos\theta} = \frac{dE}{dwcos\theta}</script><p><img src="/images/stcg/radiance.png" alt="Radiance components"></p><p>其中，$\Phi$是辐射通量，<code>A</code>是收到光照影响的区域，$\omega$是立体角，$cos\theta$ 是一个缩放因子，随着角度的变化，光线逐渐消失。</p><p><img src="/images/stcg/05explain.jpg" alt="Radiant Intensity, Irradiance and radiance"></p><h3 id="反射方程"><a href="#反射方程" class="headerlink" title="反射方程"></a>反射方程</h3><script type="math/tex; mode=display">L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i</script><p>其中的$n \cdot \omega_i$等同于$cos\theta_i$。</p><p>$L_0$ 表示了从$\omega_0$方向上观察，光线投射到点<code>p</code>上反射出来的辐照度。就是要把以点<code>p</code>为中心的单位表面接收到的所有入射光，在半球领域Ω内所有方向上的入射光的<code>积分(亦即求和)</code>。</p><h4 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h4><p><code>双向反射分布函数(Bidirectional reflectance distribution function, BRDF)</code>，定义了给定入射方向$w_i$上的<code>辐射照度(irradiance)</code>如何影响给定出射方向$w_o$上的<code>辐射率(radiance)</code>，定义如下。</p><script type="math/tex; mode=display">BRDF(w_i, w_o) = \frac{dL_o(w_o)}{dE_i(w_i)}</script><p><img src="/images/stcg/05brdf.jpg" alt="BRDF"></p><p>通俗来说，<code>BRDF</code>描述的是一个特定表面把一个方向收集到的能量反射到一个特定方向的能量分布。这是由材质决定的，比如漫反射材质，收到的能量会被均等的分到各个上半球方向上。</p><p><code>BRDF</code>基于微平面理论来近似的求得材质的反射与折射属性。对于一个BRDF，为了实现物理学上的可信度，它必须遵守能量守恒定律，也就是说反射光线的总和永远不能超过入射光线的总量。严格上来说，同样采用$\omega_i$和$\omega_0$作为输入参数的<code>Blinn-Phong</code>光照模型也被认为是一个<code>BRDF</code>。然而由于<code>Blinn-Phong</code>模型并没有遵循能量守恒定律，属于经验模型，不被认为是基于物理的渲染。</p><p>再回到反射方程，查看公式容易理解，反射方程中的$f_r$即为<code>BRDF</code>，根据<code>BRDF</code>的定义，反映了对于某个入射方向，出射方向的辐照度，所以对于每一个入射方向，用$f_r$乘以该方位角的<code>radiance</code>，即可得到对这一方向入射光反射出光的照度，再对半球面各个方向，所有方位角得到的结果积分，就可以得到在点<code>p</code>接收到的所有光，在某一方向的出射照度。</p><p>另一个理解方法是$L_i(p,\omega_i) n \cdot \omega_i  d\omega_i$即入射的<code>irradiance</code>，而$f_r$为<code>radiance</code>和<code>irradiance</code>的比值，使用$f_r$乘以<code>irradiance</code>即可得到出射的<code>radiance</code>，再求积分即可。</p><p>基于反射率公式是围绕所有入射辐射率的总和，也就是辐照度来计算的，所以我们需要计算的就不只是是单一的一个方向上的入射光，而是一个以点<code>p</code>为球心的半球领域Ω内所有方向上的入射光。一个<code>半球领域(Hemisphere)</code>可以描述为以平面法线<code>n</code>为轴所环绕的半个球体。</p><p><img src="/images/stcg/hemisphere.png" alt="hemisphere"></p><p><strong>注：通用的渲染方程可以理解为反射方程加上一个自发光项。</strong></p><h4 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h4><p>这是一个简化版本的渲染方程式。用<code>BRDF</code>乘以入射的辐照度即得到外向的辐射。</p><script type="math/tex; mode=display">L_o(\omega_i, \omega_o) = BRDF(w_i, w_o) dE_i</script><p>根据上面<code>Radiance</code>那一节推导的$dE = L d\omega cos\theta$，代入上式得</p><script type="math/tex; mode=display">L_o(\omega_i, \omega_o) = BRDF(w_i, w_o) L_i d\omega_i cos\theta_i</script><p>最后，考虑各个方向的光，因此对上式求积分，得到</p><script type="math/tex; mode=display">L_o = \underset{i\in in}{\int } BRDF(w_i, w_o) L_i cos\theta_i d\omega_i</script><p>有时为了便于计算，转换称球面坐标的表示方法。</p><p><img src="/images/stcg/05d_solid_angles.jpg" alt="Differential Solid Angle"></p><p>根据上图，$d\omega_i = \sin(\theta) d\theta d\phi$，代入上面的式子得到下式，这里可以这样理解：因为立体角在空间中是均匀分布的，使用$d\omega$即可，但是转换成球面坐标的表示方法，$\theta$在接近<code>0</code>的时候采样会更多，在接近$\frac{\pi}{2}$时更少，所以乘以$sin(\theta)$作为补偿项。</p><p><img src="/images/stcg/change_angle.jpg" alt="the differential solid angle can be defined in terms of the differential polar (θ) and azimuthal (ϕ) angles"></p><script type="math/tex; mode=display">L_o = {\int_{\phi=0}^{2\pi}}{ \int_{\theta=0}^{\pi/2}} BRDF(w_i, w_o) L_i sin(\theta) d \theta d \phi</script><h4 id="Cook-Torrance-BRDF"><a href="#Cook-Torrance-BRDF" class="headerlink" title="Cook-Torrance BRDF"></a>Cook-Torrance BRDF</h4><p><code>BRDF</code>基于微平面理论来近似的求得材质的反射与折射属性。对于一个BRDF，为了实现物理学上的可信度，它必须遵守能量守恒定律，也就是说反射光线的总和永远不能超过入射光线的总量。严格上来说，同样采用$\omega_i$和$\omega_0$作为输入参数的<code>Blinn-Phong</code>光照模型也被认为是一个<code>BRDF</code>。然而由于<code>Blinn-Phong</code>模型并没有遵循能量守恒定律，属于经验模型，不被认为是基于物理的渲染。</p><p>目前最常用的基于物理的渲染模型是<code>Cook-Torrance BRDF模型</code>，有漫反射和镜面反射两个部分，公式如下，其中$k_d$是早先提到过的入射光线中被折射部分的能量所占的比率，而$k_s$是被反射部分的比率。</p><script type="math/tex; mode=display">f_r = k_d f_{lambert} +  k_s f_{cook-torrance}</script><p>第一部分漫反射部分$f_{lambert}$被称为<code>Lambertian漫反射</code>，通常用$f_{lambert} = \frac{\rho}{\pi}$计算。$\rho$是<code>反照率(Albedo)</code>，除以$\pi$的原因是如下，为了对漫反射光进行标准化，因为前面含有<code>BRDF</code>的积分方程是受$\pi$影响的。简单推导如下(利用了漫反射<code>BRDF</code>不再和入射出射光有关，因而是一个常数)：</p><p><img src="/images/stcg/05diffuse.jpg" alt="light is equally reflected in each output direction"></p><p>公式第二部分镜面反射部分形式如下：</p><script type="math/tex; mode=display">f_{cook-torrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}</script><p>下面分别分析函数<code>D, F ,G</code>。</p><p>在微表面理论中，物体表面被分为无数个微小的镜面，根据表面的粗糙程度不同，微镜面的分布也不同，以此模拟不同材质的粗糙程度，对于镜面来说，只有法线方向和中间向量重合的时候反射光线才有效，函数D是一个正态分布函数，就是用来衡量中间向量H和法线重合的分布，在该模型中采用<code>TROWBRIDGE-REITZ GGX</code>计算，从公式中可以看到，当粗糙度$\alpha$越低即表面越光滑，与中间向量取向一致的微平面将会集中在很小的半径范围内，造成明亮的的点：</p><script type="math/tex; mode=display">NDF_{GGX TR}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2 (\alpha^2 - 1) + 1)^2}</script><p>因为微表面分布不均，反射出来的光线可能为被同一物体的其他微表面所遮挡，几何函数G使用SCHLICK-GGX近似计算求得微平面间相互遮蔽的比率，并使用史密斯方法把几何遮蔽和几何阴影都纳入其中：</p><script type="math/tex; mode=display">G_{SchlickGGX}(n, v, k) = \frac{n \cdot v}{(n \cdot v)(1 - k) + k }</script><p>当垂直观察的时候，任何物体或者材质表面都有一个基础反射率<code>(Base Reflectivity)</code>，但是如果以一定的角度往平面上看的时候所有反光都会变得明显起来。比如用垂直的视角观察木制或金属的桌面，此时一定只有最基本的反射性。但是如果你从近乎90度（与法线的夹角）的角度观察的话反光就会变得明显的多。如果从理想的90度视角观察，所有的平面理论上来说都能完全的反射光线。这种现象因菲涅尔而闻名，并体现在了菲涅尔方程之中。</p><p>菲涅尔方程是一个相当复杂的方程式，不过幸运的是菲涅尔方程可以用Fresnel-Schlick近似法求得近似解：</p><script type="math/tex; mode=display">F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0) ( 1 - (h \cdot v))^5</script><p>$F_0$表示平面的基础反射率，它是利用所谓<code>折射指数(Indices of Refraction)</code>或者说<code>IOR</code>计算得出的。</p><p>最后得到<code>Cook-Torrance</code>的反射率方程，</p><script type="math/tex; mode=display">L_o(p,\omega_o) = \int\limits_{\Omega} (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})L_i(p,\omega_i) n \cdot \omega_i  d\omega_i</script><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://web.stanford.edu/class/cs148/lectures.html" target="_blank" rel="noopener">Stanford CS148 Introduction to Computer Graphics and Imaging (Fall 2019)</a></li><li>Fundamentals of Computer Graphics, 4th Edition.<br>Steve Marschner and Peter Shirley, A K Peters/CRC Press, 2015. (Ch10)</li><li>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 4.3 (8th Edition) Dave Shreiner, Addison-Wesley Professional, 2013. (Ch7)</li><li><a href="http://www.codinglabs.net/article_physically_based_rendering.aspx" target="_blank" rel="noopener">Article - Physically Based Rendering</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;经验模型&quot;&gt;&lt;a href=&quot;#经验模型&quot; class=&quot;headerlink&quot; title=&quot;经验模型&quot;&gt;&lt;/a&gt;经验模型&lt;/h3&gt;&lt;p&gt;经典光照模型属于经验模型，单独计算&lt;code&gt;环境光(ambient)&lt;/code&gt;，&lt;code&gt;漫反射光(diffuse)</summary>
      
    
    
    
    
    <category term="Computer Graphics" scheme="https://12vv.github.io/tags/Computer-Graphics/"/>
    
    <category term="BRDF" scheme="https://12vv.github.io/tags/BRDF/"/>
    
    <category term="radiometry" scheme="https://12vv.github.io/tags/radiometry/"/>
    
  </entry>
  
  <entry>
    <title>Light and Color</title>
    <link href="https://12vv.github.io/2020/02/18/stcg02/"/>
    <id>https://12vv.github.io/2020/02/18/stcg02/</id>
    <published>2020-02-18T07:00:00.000Z</published>
    <updated>2021-08-13T15:17:06.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="电磁波谱-Electromagnetic-Spectrum"><a href="#电磁波谱-Electromagnetic-Spectrum" class="headerlink" title="电磁波谱 (Electromagnetic Spectrum)"></a>电磁波谱 (Electromagnetic Spectrum)</h3><p>依照波长的长短、频率以及波源的不同，电磁波谱可大致分为：无线电波、微波、红外线、可见光、紫外线、x射线和伽马射线。<br><img src="/images/stcg/electro.png" alt></p><p>波长((\lambda))和能量((\Delta E))的关系：(\lambda \Delta E = 1239.9)</p><h3 id="光谱-Spectrum"><a href="#光谱-Spectrum" class="headerlink" title="光谱 (Spectrum)"></a>光谱 (Spectrum)</h3><p>光谱可以看成是光子数目和波长的关系，又因为同样波长的光子，数目越多能量越大，所以也可以看成是波长和能量的关系。<br><img src="/images/stcg/dayavgspectrum.jpg" alt></p><p>然而基于上述关系构建的光谱渲染器(spectral renderer)代价太过高昂，因此考虑到使用红绿蓝的组合来模拟光(暂不考虑光的偏振，衍射和干涉等)。</p><h3 id="人眼-Human-eye"><a href="#人眼-Human-eye" class="headerlink" title="人眼 (Human eye)"></a>人眼 (Human eye)</h3><p>人的视网膜(retina)上的光度感应器(photodetector)是<code>视杆细胞(rods)</code>和<code>视锥细胞(cones)</code>。</p><p><img src="/images/stcg/retina.jpeg" alt></p><p><code>视锥细胞(cones)</code>在视网膜中央凹处(<code>fovea</code>)密度最大，而此处几乎没有<code>视杆细胞(rods)</code>。<code>视杆细胞(rods)</code>和<code>视锥细胞(cones)</code>的分布如下图所示。<br><img src="/images/stcg/rc.jpeg" alt></p><p>视杆细胞是感受弱光刺激的细胞，对光线的强弱反应非常敏感，主要在弱光下发挥作用，不能辨别颜色。比如，猫头鹰视网膜中视杆细胞较多，故夜间活动视觉灵敏。视锥细胞则可以在正常明度下，为我们提供视觉信息。</p><p>实际上在视网膜上存在着三种用来感知颜色的视锥细胞，他们分别叫做<code>S(Short)-视锥细胞</code>，<code>M(Middle)-视锥细胞</code>，<code>L(Long)-视锥细胞</code>，对应着波长的短，中，长。</p><p>每种视锥细胞都对某一个特定波长的颜色异常敏感。一般来说，<code>S-视锥细胞</code>对波长<code>420nm</code>的光线最为敏感，<code>M-视锥细胞</code>对<code>530nm</code>的波长最为敏感，而<code>L-视锥细胞</code>对于<code>560nm</code>的波长最为敏感。这也是为什么在计算机图形学中，颜色用<code>红绿蓝三原色red-green-blue (RGB)</code>来表示的原因。</p><p><img src="/images/stcg/conesrespond.jpg" alt></p><h3 id="三色理论-Trichromatic-Theory"><a href="#三色理论-Trichromatic-Theory" class="headerlink" title="三色理论 (Trichromatic Theory)"></a>三色理论 (Trichromatic Theory)</h3><h4 id="格拉斯曼颜色定律-Grassmann’s-laws"><a href="#格拉斯曼颜色定律-Grassmann’s-laws" class="headerlink" title="格拉斯曼颜色定律 (Grassmann’s laws)"></a>格拉斯曼颜色定律 (Grassmann’s laws)</h4><ul><li>Symmetry law</li><li>Transitive law</li><li>Proportionality law</li><li>Additivity law</li></ul><h4 id="配色实验-Color-Matching-Experiments"><a href="#配色实验-Color-Matching-Experiments" class="headerlink" title="配色实验 (Color Matching Experiments)"></a>配色实验 (Color Matching Experiments)</h4><blockquote><p>使用该实验确定的假想观察者，可将任意的可见光谱功率分布转换为一组三刺激值，从而量化地描述人类色觉。</p></blockquote><p>简单来说，就是认为调整三种不同波长的单色光(波长为分别为435.8, 546.1, 700 nm)的组合，使其和另一种颜色匹配(同色异谱：一种颜色的再现与观察颜色的光源特性有一定的关系。)，然后记录下这个波段的光对应的三原色的系数。得到下面的曲线。</p><p><img src="/images/stcg/matchexp.jpg" alt></p><h4 id="加色与减色-Additive-vs-Subtractive-Colors"><a href="#加色与减色-Additive-vs-Subtractive-Colors" class="headerlink" title="加色与减色 (Additive vs Subtractive Colors)"></a>加色与减色 (Additive vs Subtractive Colors)</h4><p><img src="/images/stcg/addsub.jpg" alt></p><h4 id="色彩空间-Color-Space"><a href="#色彩空间-Color-Space" class="headerlink" title="色彩空间 (Color Space)"></a>色彩空间 (Color Space)</h4><p><img src="/images/stcg/Colorspace.png" alt></p><p><img src="/images/stcg/rgbcs.jpg" alt="RGB色彩空间"></p><p>由于每个显示设备有自己<code>原色(primaries)的光谱分布(spectral distributions)</code>，所以即使有一张图片在RGB空间中定义，在不同设备上显示也可能不同。而且，使用RGB来表示颜色也有点不符合直觉，因为当我们看到“黄色”的时候，并不觉得是等同的“红”光和“绿”光混合成的，我们只觉得是一种“黄”色的光。所以，可以利用矩阵将RGB空间的转换为<code>CIE color spaces</code>或者它的变体(一个维度表示brightness，另外两个维度表示chromaticity)。</p><p><img src="/images/stcg/rgb4.jpg" alt="RGB色彩空间"></p><p><img src="/images/stcg/trans.jpg" alt="Transformations for standard RGB color spaces"></p><p>还有一种方法是使用更加直观的表示方法，即<code>Hue-Saturation-Value (HSV) color space</code>。</p><p><img src="/images/stcg/hsv.jpg" alt="Hue-Saturation-Value (HSV) color space"></p><ul><li>色调(H, Hue): 用角度度量，取值范围为0°～360°，从红色开始按逆时针方向计算，红色为0°，绿色为120°,蓝色为240°。</li><li>饱和度(S, Saturation): 表示颜色接近光谱色的程度。一种颜色，可以看成是某种光谱色与白色混合的结果。其中光谱色所占的比例愈大，颜色接近光谱色的程度就愈高(颜色越鲜明)，颜色的饱和度也就愈高。</li><li>明度(V/B, Value/Brightness): 明度表示颜色明亮的程度，对于光源色，明度值与发光体的光亮度有关；对于物体色，此值和物体的透射比或反射比有关。</li></ul><h3 id="色调映射-Tone-Mapping"><a href="#色调映射-Tone-Mapping" class="headerlink" title="色调映射 (Tone Mapping)"></a>色调映射 (Tone Mapping)</h3><blockquote><p>色调映射(Tone Mapping/ Tone Reproduction)，是在有限动态范围(dynamic range)媒介上近似显示高动态范围图像的一项计算机图形学技术。</p></blockquote><p>本质上来讲，色调映射是要解决的问题是进行大幅度的对比度衰减将场景亮度变换到可以显示的范围，同时要<strong>保持图像细节与颜色等对于表现原始场景非常重要的信息</strong>。</p><h4 id="动态范围-Dynamic-Range"><a href="#动态范围-Dynamic-Range" class="headerlink" title="动态范围 (Dynamic Range)"></a>动态范围 (Dynamic Range)</h4><blockquote><p>动态范围是可变化信号(例如声音或光)最大值和最小值的比值。也可以用以10为底的对数(分贝)或以2为底的对数表示。</p></blockquote><p>在传统图像中，每一个像素的RGB分别用用一位(byte)来表示，所以对于<code>低动态范图像(Low Dynamic Range images)</code>，每个颜色通道仅有256个不同的值。所以要保存<code>高动态范围成像(High Dynamic Range Imaging)</code>需要很大的文件格式。</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>为此，可以采用<code>色调映射</code>技术压缩高动态范围的图像的信息，得到的是JPEG格式图像。</p><p>另外，<code>高动态范围成像(High Dynamic Range Imaging)</code>的目的就是要正确地表示真实世界中从太阳光直射到最暗的阴影这样大的范围亮度。但是，CRT、LCD、打印机以及其它图像显示方法只能显示有限动态范围的图像，这些设备是低动态范围(Low Dynamic Range)的。所以采用<code>色调映射</code>技术来将HDR图像呈现到低动态范围的显示设备上。</p><p>由于目前大多数显示设备基于<code>8比特数模变换器(eight-bit D/A converters)</code>，所以可以把<code>色调映射</code>的过程看作是浮点数值到比特数的转换过程。</p><h4 id="基于频率的方法-Frequency-Based-Operators"><a href="#基于频率的方法-Frequency-Based-Operators" class="headerlink" title="基于频率的方法 (Frequency-Based Operators)"></a>基于频率的方法 (Frequency-Based Operators)</h4><p>假设图像中每个像素的亮度(luminance)近似于物体表面的<code>反射率(reflectance)</code>和<code>照度(illuminance)</code>的乘积。</p><script type="math/tex; mode=display">L_v(x, y) = r(x, y)E_v(x, y)</script><p>下标v表示使用(photometrically weighted quantities)，取对数得到：</p><script type="math/tex; mode=display">D(x, y) = log(L_v(x, y)) = log(r(x, y)E_v(x, y)) = log(r(x, y)) + log(E_v(x, y))</script><p>这样，成像被分成了<code>反射率(reflectance)</code>和<code>照度(illuminance)</code>两个分量的叠加。</p><p>因为<code>反射率(reflectance)</code>是<code>低动态范围(Low Dynamic Range)</code>，而<code>照度(illuminance)</code>是<code>高动态范围(High Dynamic Range)</code>的，如果能想办法分离这两个成分，主要压缩<code>高动态范围(High Dynamic Range)</code>部分即可。</p><p>对于典型的漫射场景，由于带纹理的表面以及表面边缘的存在，反射率分量倾向于表现出高<code>空间频率(spatial frequencies)</code>。而照度往往是空间上缓慢变化的函数。所以可以依据频率(使用傅立叶变换等方法)分离两个分量。压缩<code>照度(illuminance)</code>分量而保持<code>反射率(reflectance)</code>分量不变。</p><p>下面是一个应用例子，<code>Bilateral filtering</code>就是基于这个方法。</p><p><img src="/images/stcg/bf.jpg" alt="Bilateral filtering removes small details but preserves sharp gradients (left). The associated detail layer is shown on the right."></p><h3 id="Gamma校正-Gamma-Correction"><a href="#Gamma校正-Gamma-Correction" class="headerlink" title="Gamma校正 (Gamma Correction)"></a>Gamma校正 (Gamma Correction)</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><blockquote><p>首先，我们的眼睛不像照相机那样感知光线。</p></blockquote><p>当两倍的光子击中传感器时，传感器就接收到两倍的信号(“线性”)。而当我们感知到两倍的光的时候只是觉得亮了一点(非线性)。</p><p><img src="/images/stcg/camvseyes.jpg" alt></p><p>与相机相比，人眼对暗色调的变化比对亮色调的变化更敏感。这种特性有一个生物学上的原因: 它使我们的视觉能够在更广泛的亮度范围内工作。</p><p>伽马矫正是我们眼睛的光敏感度和相机的光敏感度之间的转换。 当一个数字图像被保存下来时，它被“<code>伽玛编码(gamma encoded)</code>”—-使一个数字图像中两倍的数值我们所感知的两倍亮度的数值更为接近。</p><h4 id="Gamma定义"><a href="#Gamma定义" class="headerlink" title="Gamma定义"></a>Gamma定义</h4><script type="math/tex; mode=display">Vout = Vin^{gamma}</script><ul><li><code>Vout</code>: 是输出亮度值。</li><li><code>Vin</code>: 输入/实际亮度值。</li></ul><p>当<code>gamma&lt;1</code>时，直线向上拱起，当<code>gamma&gt;1</code>时则向下凹。</p><blockquote><p>另外，伽玛编码图像能更有效地存储色调(tone)。 </p></blockquote><p>由于伽马编码将色调层次重新分配到更接近我们眼睛感知的层次，因此描述给定色调范围所需的比特更少。 也就是说，因为人眼对于暗色调更加敏感，伽马矫正就在暗色调区间划分了更多层，提高了存储空间的利用率。否则，过多的比特将用于描述较明亮的色调(相机相对更敏感，人眼较不敏感) ，而缺少比特将用于描述较暗的色调。<br><img src="/images/stcg/gamma2.jpg" alt></p><p>另外，如上图所示，伽玛编码将色调几乎均匀地在整个范围内划分(perceptually uniform)。</p><h4 id="GAMMA-WORKFLOW"><a href="#GAMMA-WORKFLOW" class="headerlink" title="GAMMA WORKFLOW"></a>GAMMA WORKFLOW</h4><p><img src="/images/stcg/workflow.jpg" alt></p><h5 id="Image-Gamma"><a href="#Image-Gamma" class="headerlink" title="Image Gamma"></a>Image Gamma</h5><p>通常<code>image gamma</code>的设置嵌入在图像文件中，大多数图像设置gamma值为1/2.2，(如上图左一)。当相机将捕获的图像转换为标准<code>JPEG</code>或<code>TIFF</code>文件格式时应用gamma将本地相机的色调层次重新分配到感知更加均匀的层次中。<br><img src="/images/stcg/imggamma.jpg" alt></p><h5 id="Display-Gamma"><a href="#Display-Gamma" class="headerlink" title="Display Gamma"></a>Display Gamma</h5><p>主要目的是补偿<code>image gamma</code>，使得图像显示在屏幕上有合适的亮度。更高的<code>Display Gamma</code>导致更暗且对比度更高的图像。</p><p><img src="/images/stcg/disgamma.jpg" alt></p><h5 id="System-Gamma"><a href="#System-Gamma" class="headerlink" title="System Gamma"></a>System Gamma</h5><p>同<code>viewing gamma</code>。为了更真实的再现一个场景，理想的情况是<code>gamma = 1.0</code>，那么<code>Vout = Vin</code>，即原场景的光与屏幕上显示的光相同。然而为了提高对比度，会设置gamma略大于1。这样可以弥补显示设备的<code>动态范围(dynamic range)</code>的限制。</p><blockquote><p>Gamma correction is applied to the gamma encoded (compressed)<br>images to convert them back to the original scene luminance.</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="http://web.stanford.edu/class/cs148/lectures.html" target="_blank" rel="noopener">Stanford CS148 Introduction to Computer Graphics and Imaging (Fall 2019)</a></li><li>Fundamentals of Computer Graphics, 4th Edition.<br>Steve Marschner and Peter Shirley, A K Peters/CRC Press, 2015. (Ch21, Ch22, Ch23)</li><li>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 4.3 (8th Edition) Dave Shreiner, Addison-Wesley Professional, 2013. (Ch7)</li><li><a href="https://www.scratchapixel.com/lessons/digital-imaging/colors/introduction" target="_blank" rel="noopener">Introduction to Light, Color and Color Space</a></li><li><a href="https://www.cambridgeincolour.com/tutorials/gamma-correction.htm" target="_blank" rel="noopener">UNDERSTANDING GAMMA CORRECTION</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;电磁波谱-Electromagnetic-Spectrum&quot;&gt;&lt;a href=&quot;#电磁波谱-Electromagnetic-Spectrum&quot; class=&quot;headerlink&quot; title=&quot;电磁波谱 (Electromagnetic Spectrum)&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="Computer Graphics" scheme="https://12vv.github.io/tags/Computer-Graphics/"/>
    
    <category term="gamma correction" scheme="https://12vv.github.io/tags/gamma-correction/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://12vv.github.io/2018/01/01/hello-world/"/>
    <id>https://12vv.github.io/2018/01/01/hello-world/</id>
    <published>2018-01-01T07:00:00.000Z</published>
    <updated>2019-05-07T05:24:35.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HELLO-WORLD"><a href="#HELLO-WORLD" class="headerlink" title="HELLO WORLD"></a>HELLO WORLD</h2><a id="more"></a><h3 id="Do-Not-Go-Gentle-into-That-Good-Night"><a href="#Do-Not-Go-Gentle-into-That-Good-Night" class="headerlink" title="Do Not Go Gentle into That Good Night"></a>Do Not Go Gentle into That Good Night</h3><p><strong> FROM Dylan Thomas</strong></p><p><em>Do not go gentle into that good night,</em>  </p><p><em>Old age should burn and rave at close of day;</em></p><p><em>Rage, rage against the dying of the light.</em></p><p><em>Though wise men at their end know dark is right,</em></p><p><em>Because their words had forked no lightning they.</em></p><p><em>Do not go gentle into that good night.</em></p><p><em>Good men, the last wave by, crying how bright.</em></p><p><em>Their frail deeds might have danced in a green bay,</em></p><p><em>Rage, rage against the dying of the light.</em></p><p><em>Wild men who caught and sang the sun in flight.</em></p><p><em>And learn, too late, they grieved it on its way.</em></p><p><em>Do not go gentle into that good night.</em></p><p><em>Grave men, near death, who see with blinding sight.</em></p><p><em>Blind eyes could blaze like meteors and be gay.</em></p><p><em>Rage, rage against the dying of the light.</em></p><p><em>And you, my father, there on the sad height,</em></p><p><em>Curse, bless, me now with your fierce tears, I pray.</em></p><p><em>Do not go gentle into that good night.</em></p><p><em>Rage, rage against the dying of the light.</em></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;HELLO-WORLD&quot;&gt;&lt;a href=&quot;#HELLO-WORLD&quot; class=&quot;headerlink&quot; title=&quot;HELLO WORLD&quot;&gt;&lt;/a&gt;HELLO WORLD&lt;/h2&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
