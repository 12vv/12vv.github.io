<!DOCTYPE html>
<html lang>

<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Jaythan">



    <meta name="description" content="Do not go into that gentle night.">



<title>代码复用模式 | Jay&#39;s Blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


    


<link rel="alternate" href="/atom.xml" title="Jay's Blog" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Jay&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Jay&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">代码复用模式</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 30, 2021&nbsp;&nbsp;00:00:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <blockquote>
<p>摘自：_JavaScript patterns_ 中译本 - 《JavaScript 模式》第六章</p>
</blockquote>
<p>代码复用是一个既重要又有趣的话题。如果你面对自己或者别人已经写好的代码，而这些代码又是经过测试的、可维护的、可扩展的、有文档的，这时候你只想写尽量少且可以被复用的代码就是一个再自然不过的想法。</p>
<p>当我们说到代码复用的时候，想到的第一件事就是继承，本章会有很大篇幅讲述这个话题，你将看到好多种方法来实现“<code>类式（classical）</code>”和一些其它方式的继承。但是，最最重要的事情，是你需要记住终极目标——<strong>代码复用</strong>。继承是达到这个目标的一种方法，但是不是唯一的。在本章，你将看到怎样基于其它对象来构建新对象，怎样使用混元，以及怎样在不使用继承的情况下只复用你需要的功能。</p>
<p>在做代码复用的工作的时候，谨记<code>Gang of Four</code>在书中给出的关于对象创建的建议：“<strong>优先使用对象创建而不是类继承</strong>”。</p>
<p>译注：《设计模式：可复用面向对象软件的基础》（Design Patterns: Elements of Reusable Object-Oriented Software）是一本设计模式的经典书籍，该书作者为 Erich Gamma, Richard Helm, Ralph Johnson 和 John Vlissides，被称为“Gang of Four”，简称“GoF”。</p>
<h2 id="类式继承-vs-现代继承模式"><a href="#类式继承-vs-现代继承模式" class="headerlink" title="类式继承 vs 现代继承模式"></a>类式继承 vs 现代继承模式</h2><p>在讨论 JavaScript 的继承这个话题的时候，经常会听到“<code>类式继承</code>”的概念，那我们先看一下什么是类式（classical）继承。<code>classical</code>一词并不是来自某些古老的、固定的或者是被广泛接受的解决方案，而仅仅是来自单词“class”。（译注：classical 也有“经典”的意思。）</p>
<p>很多编程语言都有原生的类的概念，以此作为对象的蓝本。在这些语言中，每个对象都是一个指定类的实例（instance），并且（以 Java 为例）一个对象不能在不存在对应的类的情况下存在。在 JavaScript 中，因为没有类，所以类的实例的概念没什么意义。JavaScript 的对象仅仅是简单的键值对，这些键值对都可以动态创建或者是改变。</p>
<p>但是 JavaScript 拥有<code>构造函数(constructor functions)</code>，并且有语法和使用类非常相似的<code>new</code>运算符。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Java 中你可能会这样写</span></span><br><span class="line">Person adam = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JavaScript中你可以这样</span></span><br><span class="line"><span class="keyword">var</span> adam = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>
<p>除了 Java 是强类型语言需要给<code>adam</code>添加类型<code>Person</code>外，其它的语法看起来是一样的。JavaScript 的构造函数调用方式看起来让人感觉<code>Person()</code>是一个类，但事实上，<code>Person()</code>仅仅是一个函数。语法上的相似使得非常多的开发者陷入对 JavaScript 类的思考，并且给出了很多模拟类的继承方案。这样的实现方式，我们叫它“<code>类式继承</code>”。顺便也提一下，所谓“现代”继承模式是指那些不需要你去想类这个概念的模式。</p>
<p>当需要给项目选择一个继承模式时，有不少的备选方案。你应该尽量选择那些现代继承模式，除非团队已经觉得“无类不欢”。</p>
<p>本章先讨论类式继承，然后再关注现代继承模式。</p>
<h2 id="类式继承的期望结果"><a href="#类式继承的期望结果" class="headerlink" title="类式继承的期望结果"></a>类式继承的期望结果</h2><p>实现类式继承的目标是基于构造函数<code>Child()</code>来创建一个对象，然后从另一个构造函数<code>Parent()</code>获得属性。</p>
<p>尽管我们是在讨论类式继承，但还是尽量避免使用“类”这个词。“<code>构造函数</code>”或者“<code>constructor</code>”虽然更长，但是更准确，不会让人迷惑。通常情况下，应该努力避免在跟团队沟通的时候使用“类”这个词，因为在 JavaScript 中，很可能每个人都会有不同的理解。</p>
<p>下面是定义两个构造函数<code>Parent()</code>和<code>Child()</code>的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Parent构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">"Adam"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给原型增加方法</span></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空的Child构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承</span></span><br><span class="line">inherit(Child, Parent);</span><br></pre></td></tr></table></figure>
<p>上面的代码定义了两个构造函数<code>Parent()</code>和<code>Child()</code>，<code>say()</code>方法被添加到了<code>Parent()</code>构建函数的<code>原型 (prototype)</code>中，<code>inherit()</code>函数完成了继承的工作。<code>inherit()</code>函数并不是原生提供的，需要自己实现。让我们来看一看比较常见的实现它的几种方法。</p>
<h2 id="类式继承-1——默认模式"><a href="#类式继承-1——默认模式" class="headerlink" title="类式继承 1——默认模式"></a>类式继承 1——默认模式</h2><p>最常用的一种模式是使用<code>Parent()</code>构造函数来创建一个对象，然后把这个对象设为<code>Child()</code>的原型。这是可复用的<code>inherit()</code>函数的第一种实现方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">  C.prototype = <span class="keyword">new</span> P();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要强调的是原型（<code>prototype</code>属性）应该<strong>指向一个对象，而不是函数</strong>，所以它需要指向由被继承的构造函数创建的实例（对象），而不是构造函数自己。换句话说，请注意<code>new</code>运算符，有了它这种模式才可以正常工作。</p>
<p>之后在应用中使用<code>new Child()</code>创建对象的时候，它将通过原型拥有<code>Parent()</code>实例的功能，像下面的例子一样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br><span class="line">kid.say(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure>
<h3 id="跟踪原型链"><a href="#跟踪原型链" class="headerlink" title="跟踪原型链"></a>跟踪原型链</h3><p>在这种模式中，子对象既继承了（父对象的）“<code>自有属性</code>”（添加给<code>this</code>的实例属性，比如<code>name</code>），<strong>也继承了原型中的属性和方法</strong>（比如<code>say()</code>）。</p>
<p>我们来看一下在这种继承模式中原型链是怎么工作的。为了讨论方便，我们假设对象是内存中的一块空间，它包含数据和指向其它空间的引用。当使用<code>new Parent()</code>创建一个对象时，这样的一块空间就被分配了（图 6-1 中的 2 号），它保存着<code>name</code>属性的数据。如果你尝试访问<code>say()</code>方法（比如通过<code>(new Parent).say()</code>），2 号空间中并没有这个方法。但是在通过隐藏的链接<code>__proto__</code>指向<code>Parent()</code>构建函数的原型<code>prototype</code>属性时，就可以访问到包含<code>say()</code>方法的 1 号空间（<code>Parent.prototype</code>）了。</p>
<p>所有的这一块都是在幕后发生的，不需要任何额外的操作，但是知道它是怎样工作的有助于让你明白你正在访问或者修改的数据在哪，这是很重要的。注意，<code>__proto__</code>在这里只是为了解释原型链而存在，这个属性在语言本身中是不可用的，尽管有一些环境提供了（比如 Firefox）。</p>
<p><img src="/images/dmfyms/1.png" alt="/images/dmfyms/1.png"></p>
<p>图 6-1 Parent()构造函数的原型链</p>
<p>现在我们来看一下在使用<code>inherit()</code>函数之后再使用<code>var kid = new Child()</code>创建一个新对象时会发生什么。见图 6-2。</p>
<p><img src="/images/dmfyms/2.png" alt="/images/dmfyms/2.png"></p>
<p>图 6-2 继承后的原型链</p>
<p><code>Child()</code>构造函数是空的，也没有属性添加到<code>Child.prototype</code>上，这样，使用<code>new Child()</code>创建出来的对象都是空的，除了有隐藏的链接<code>__proto__</code>。在这个例子中，<code>__proto__</code>指向在<code>inherit()</code>函数中创建的<code>new Parent()</code>对象。</p>
<p>现在使用<code>kid.say()</code>时会发生什么？<code>3</code>号对象没有这个方法，所以通过原型链找到<code>2</code>号。<code>2</code>号对象也没有这个方法，所以也通过原型链找到<code>1</code>号，刚好有这个方法。接下来<code>say()</code>方法引用了<code>this.name</code>，这个变量也需要解析，于是沿原型链查找的过程又走了一遍。在这个例子中，<code>this</code>指向<code>3</code>号对象，它没有<code>name</code>属性，然后<code>2</code>号对象被访问，并且有<code>name</code>属性，值为“<code>Adam</code>”。</p>
<p>最后，我们看一点额外的东西，假如我们有如下的代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br><span class="line">kid.name = <span class="string">"Patrick"</span>;</span><br><span class="line">kid.say(); <span class="comment">// "Patrick"</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/dmfyms/3.png" alt="/images/dmfyms/3.png"></p>
<p>图 6-3 继承并且给子对象添加属性后的原型链</p>
<p>设定<code>kid.name</code>并没有改变<code>2</code>号对象的<code>name</code>属性，但是却直接在<code>3</code>号对象上添加了自有的<code>name</code>属性。当<code>kid.say()</code>执行时，<code>say()</code>方法会依次在<code>3</code>号对象中找，然后是<code>2</code>号，最后到<code>1</code>号，像前面说的一样。但是这一次在找<code>this.name</code>（和 kid.name 一样）时很快，因为这个属性在<code>3</code>号对象中就被找到了。</p>
<p>如果通过<code>delete kid.name</code>的方式移除新添加的属性，那么<code>2</code>号对象的<code>name</code>属性就将被暴露出来并且在查找的时候被找到。</p>
<p><strong>这种模式的缺点</strong></p>
<p>这种模式的一个缺点是既继承了（父对象的）“自有属性”，也继承了原型中的属性。大部分情况下你可能并不需要“自有属性”，因为它们更可能是为实例对象添加的，并不用于复用。</p>
<blockquote>
<p><strong>一个在构造函数上常用的规则是，用于复用的成员（译注：属性和方法）应该被添加到原型上。</strong></p>
</blockquote>
<p>在使用这个<code>inherit()</code>函数时另外一个不便是它不能够让你传参数给子构造函数，这些参数有可能是想再传给父构造函数的。考虑下面的例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> Child(<span class="string">"Seth"</span>);</span><br><span class="line">s.say(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure>
<p>这并不是我们期望的结果。事实上传递参数给父构造函数是可能的，但这样需要在每次需要一个子对象时再做一次继承，很不方便，因为需要不断地创建父对象。</p>
<h2 id="类式继承-2——借用构造函数"><a href="#类式继承-2——借用构造函数" class="headerlink" title="类式继承 2——借用构造函数"></a>类式继承 2——借用构造函数</h2><p>下面这种模式解决了从子对象传递参数到父对象的问题。它借用了父对象的构造函数，将子对象绑定到<code>this</code>，同时传入参数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">a, c, b, d</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这种模式时，只能继承在父对象的构造函数中添加到 this 的属性，不能继承原型上的成员。</p>
<p>使用借用构造函数的模式，子对象<strong>通过复制</strong>的方式继承父对象的成员，而不是像类式继承<code>1</code>中那样通过<strong>引用</strong>的方式。下面的例子展示了这两者的不同：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Article</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.tags = [<span class="string">"js"</span>, <span class="string">"css"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> article = <span class="keyword">new</span> Article();</span><br><span class="line"></span><br><span class="line"><span class="comment">//BlogPost通过类式继承1（默认模式）从article继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">BlogPost.prototype = article;</span><br><span class="line"><span class="keyword">var</span> blog = <span class="keyword">new</span> BlogPost();</span><br><span class="line"><span class="comment">//注意你不需要使用 **new Article()**，因为已经有一个实例了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//StaticPage 通过借用构造函数的方式从 Article 继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StaticPage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Article.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> page = <span class="keyword">new</span> StaticPage();</span><br><span class="line"></span><br><span class="line">alert(article.hasOwnProperty(<span class="string">"tags"</span>)); <span class="comment">// true</span></span><br><span class="line">alert(blog.hasOwnProperty(<span class="string">"tags"</span>)); <span class="comment">// false</span></span><br><span class="line">alert(page.hasOwnProperty(<span class="string">"tags"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码片段中，<code>Article()</code>被用两种方式分别继承。默认模式使<code>blog</code>可以通过原型链访问到<code>tags</code>属性，所以它自己并没有<code>tags</code>属性，<code>hasOwnProperty()</code>返回<code>false</code>。<code>page</code>对象有自己的<code>tags</code>属性，因为它是使用借用构造函数的方式继承，复制（而不是引用）了<code>tags</code>属性。</p>
<p>注意在修改继承后的<code>tags</code>属性时的不同表现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">blog.tags.push(<span class="string">"html"</span>);</span><br><span class="line">page.tags.push(<span class="string">"php"</span>);</span><br><span class="line">alert(article.tags.join(<span class="string">", "</span>)); <span class="comment">// "js, css, html"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>blog</code>对象修改了<code>tags</code>属性，同时，它也修改了父对象，因为实际上<code>blog.tags</code>和<code>article.tags</code>是引向同一个数组。而对<code>pages.tags</code>的修改并不影响父对象<code>article</code>，因为<code>pages.tags</code>在继承的时候是一份独立的拷贝。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>我们来看一下当我们使用熟悉的<code>Parent()</code>和<code>Child()</code>构造函数和这种继承模式时原型链是什么样的。为了使用这种继承模式，<code>Child()</code>有明显变化：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">"Adam"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原型上添加方法</span></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child(<span class="string">"Patrick"</span>);</span><br><span class="line">kid.name; <span class="comment">// "Patrick"</span></span><br><span class="line"><span class="keyword">typeof</span> kid.say; <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<p>如果看一下 图 6-4，就能发现<code>new Child()</code>对象和<code>Parent()</code>之间不再有链接。这是因为<code>Child.prototype</code>根本就没有被使用，它指向一个空对象。使用这种模式，<code>kid</code>拥有了自有的<code>name</code>属性，但是并没有继承<code>say()</code>方法，如果尝试调用它的话会出错。这种继承方式只是一种一次性地将父对象的属性复制为子对象的属性，并没有<code>__proto__</code>链接。</p>
<p><img src="/images/dmfyms/4.png" alt="/images/dmfyms/4.png"></p>
<p>图 6-4 使用借用构造函数模式时没有被关联的原型链</p>
<h3 id="利用借用构造函数模式实现多继承"><a href="#利用借用构造函数模式实现多继承" class="headerlink" title="利用借用构造函数模式实现多继承"></a>利用借用构造函数模式实现多继承</h3><p>使用借用构造函数模式，可以通过借用多个构造函数的方式来实现多继承：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.legs = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">this</span>.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"meaowww"</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.wings = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">this</span>.fly = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CatWings</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Cat.apply(<span class="keyword">this</span>);</span><br><span class="line">  Bird.apply(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> CatWings();</span><br><span class="line"><span class="built_in">console</span>.dir(jane);</span><br></pre></td></tr></table></figure>
<p>结果如 图 6-5，任何重复的属性都会以最后的一个值为准。</p>
<p><img src="/images/dmfyms/5.png" alt="/images/dmfyms/5.png"></p>
<p>图 6-5 在 Firebug 中查看 CatWings 对象</p>
<h3 id="借用构造函数的利与弊"><a href="#借用构造函数的利与弊" class="headerlink" title="借用构造函数的利与弊"></a>借用构造函数的利与弊</h3><p>这种模式的一个明显的弊端就是<strong>无法继承原型</strong>。如前面所说，原型往往是添加可复用的方法和属性的地方，这样就不用在每个实例中再创建一遍。</p>
<p>这种模式的一个好处是获得了父对象自有成员的拷贝，不存在子对象意外改写父对象属性的风险。</p>
<p>那么，在上一个例子中，怎样使一个子对象也能够继承原型属性呢？怎样能使 kid 可以访问到 say()方法呢？下一种继承模式解决了这个问题。</p>
<h2 id="类式继承-3——借用并设置原型"><a href="#类式继承-3——借用并设置原型" class="headerlink" title="类式继承 3——借用并设置原型"></a>类式继承 3——借用并设置原型</h2><p>综合以上两种模式，首先借用父对象的构造函数，然后将子对象的原型设置为父对象的一个新实例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">a, c, b, d</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>
<p>这样做的好处是子对象获得了父对象的自有成员，也获得了父对象中可复用的（在原型中实现的）方法。子对象也可以传递任何参数给父构造函数。这种行为可能是最接近 Java 的，子对象继承了父对象的所有东西，同时可以安全地修改自己的属性而不用担心修改到父对象。</p>
<p>一个弊端是父构造函数被调用了两次，所以不是很高效。最后，（父对象的）自有属性（比如这个例子中的<code>name</code>）也被继承了两次。</p>
<p>我们来看一下代码并做一些测试：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">"Adam"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在原型上添加方法</span></span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Parent.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child(<span class="string">"Patrick"</span>);</span><br><span class="line">kid.name; <span class="comment">// "Patrick"</span></span><br><span class="line">kid.say(); <span class="comment">// "Patrick"</span></span><br><span class="line"><span class="keyword">delete</span> kid.name;</span><br><span class="line">kid.say(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure>
<p>跟前一种模式不一样，现在<code>say()</code>方法被正确地继承了。可以看到<code>name</code>也被继承了两次，在删除掉自己的拷贝后，在原型链上的另一个就被暴露出来了。</p>
<p>图 6-6 展示了这些对象之间的关系。这些关系有点像 图 6-3 中展示的，但是获得这种关系的方法是不一样的。</p>
<p><img src="/images/dmfyms/6.png" alt="/images/dmfyms/6.png"></p>
<p>图 6-6 除了继承“自己的属性”外，原型链也被保留了</p>
<h2 id="类式继承-4——共享原型"><a href="#类式继承-4——共享原型" class="headerlink" title="类式继承 4——共享原型"></a>类式继承 4——共享原型</h2><p>不像前一种类式继承模式需要调用两次父构造函数，下面这种模式根本不会涉及到调用父构造函数的问题。</p>
<p>一般的经验是<strong>将可复用的成员放入原型</strong>中而不是<code>this</code>。从继承的角度来看，则是任何应该被继承的成员都应该放入原型中。这样你只需要设定子对象的原型和父对象的原型一样即可：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">  C.prototype = P.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式的原型链很短并且查找很快，因为所有的对象实际上共享着同一个原型。但是这样也有弊端，那就是如果子对象或者在继承关系中的某个地方的任何一个子对象修改这个原型，将影响所有的继承关系中的父对象。（译注：指会影响到所有从这个原型中继承的对象所依赖的共享原型上的成员。）</p>
<p>如 图 6-7，子对象和父对象共享同一个原型，都可以访问<code>say()</code>方法。但是，子对象不继承<code>name</code>属性。</p>
<p><img src="/images/dmfyms/7.png" alt="/images/dmfyms/7.png"></p>
<p>图 6-7 （父子对象）共享原型时的关系</p>
<h2 id="类式继承-5——临时构造函数"><a href="#类式继承-5——临时构造函数" class="headerlink" title="类式继承 5——临时构造函数"></a>类式继承 5——临时构造函数</h2><p>下一种模式通过打断父对象和子对象原型的直接链接解决了共享原型时的问题，同时还从原型链中获得其它的好处。</p>
<p>下面是这种模式的一种实现方式，<code>F()</code>函数是一个空函数，它充当了子对象和父对象的代理。<code>F()</code>的<code>prototype</code>属性指向父对象的原型。子对象的原型是这个空函数的一个实例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模式有一种和默认模式（类式继承 1）明显不一样的行为，因为在这里子对象只继承原型中的属性（图 6-8）。</p>
<p><img src="/images/dmfyms/8.png" alt="/images/dmfyms/8.png"></p>
<p>图 6-8 使用临时（代理）构造函数 F()实现类式继承</p>
<p>这种模式通常情况下都是一种很棒的选择，因为原型本来就是存放复用成员的地方。在这种模式中，父构造函数添加到<code>this</code>中的任何成员都不会被继承。</p>
<p>我们来创建一个子对象并且检查一下它的行为：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure>
<p>如果你访问<code>kid.name</code>将得到<code>undefined</code>。在这个例子中，<code>name</code>是父对象自己的属性，而在继承的过程中我们并没有调用<code>new Parent()</code>，所以这个属性并没有被创建。当访问<code>kid.say()</code>时，它在<code>3</code>号对象中不可用，所以在原型链中查找，<code>4</code>号对象也没有，但是<code>1</code>号对象有，它在内存中的位置会被所有从<code>Parent()</code>创建的构造函数和子对象所共享。</p>
<h3 id="存储父类（Superclass）"><a href="#存储父类（Superclass）" class="headerlink" title="存储父类（Superclass）"></a>存储父类（Superclass）</h3><p>在上一种模式的基础上，还可以添加一个指向原始父对象的引用。这很像其它语言中访问<code>超类（superclass)</code>的情况，有时候很方便。</p>
<p>我们将这个属性命名为“<code>uber</code>”，因为“<code>super</code>”是一个保留字，而“<code>superclass</code>”则可能误导别人认为 JavaScript 拥有类。下面是这种类式继承模式的一个改进版实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  C.uber = P.prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重置构造函数引用"><a href="#重置构造函数引用" class="headerlink" title="重置构造函数引用"></a>重置构造函数引用</h3><p>这个近乎完美的模式上还需要做的最后一件事情就是重置<code>构造函数 (constructor)</code>的指向，以便未来在某个时刻能被正确地使用。</p>
<p>如果不重置构造函数的指向，那所有的子对象都会认为<code>Parent()</code>是它们的构造函数，而这个结果完全没有用。使用前面的<code>inherit()</code>的实现，你可以观察到这种行为：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent，Child，实现继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">inherit(Child, Parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">var</span> kid = <span class="keyword">new</span> Child();</span><br><span class="line">kid.constructor.name; <span class="comment">// "Parent"</span></span><br><span class="line">kid.constructor === Parent; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><code>constructor</code>属性很少被用到，但是在运行时检查对象很方便。你可以重新将它指向期望的构造函数而不影响功能，因为这个属性更多是“信息性”的。（译注：即它更多的时候是在提供信息而不是参与到函数功能中。）</p>
<p>最终，这种类式继承的<code>Holy Grail</code>版本看起来是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = P.prototype;</span><br><span class="line">  C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  C.uber = P.prototype;</span><br><span class="line">  C.prototype.constructor = C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似这样的函数也存在于<code>YUI</code>库（也许还有其它库）中，它将类式继承的方法带给了没有类的语言。如果你决定使用类式继承，那么这是最好的方法。</p>
<blockquote>
<p>“<code>代理函数</code>”或者“<code>代理构造函数</code>”也是指这种模式，因为临时构造函数是被用作获取父构造函数原型的代理。</p>
</blockquote>
<p>一种常见的对<code>Holy Grail</code>模式的优化是<strong>避免每次需要继承的时候都创建一个临时（代理）构造函数</strong>。事实上创建一次就足够了，以后只需要修改它的原型即可。你可以用一个即时函数来将代理函数存储到闭包中：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">C, P</span>) </span>&#123;</span><br><span class="line">    F.prototype = P.prototype;</span><br><span class="line">    C.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    C.uber = P.prototype;</span><br><span class="line">    C.prototype.constructor = C;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<h2 id="Klass"><a href="#Klass" class="headerlink" title="Klass"></a>Klass</h2><p>有很多<code>JavaScript</code>类库模拟了类，创造了新的语法糖。这些类库具体的实现方式可能会不一样，但是基本上都有一些共性，包括：</p>
<ul>
<li>有一个约定好的方法，如<code>initialize</code>、<code>_init</code>或者其它相似的名字，会被自动调用，来充当类的构造函数</li>
<li>类可以从其它类继承</li>
<li>在子类中可以访问到父类（superclass）</li>
</ul>
<blockquote>
<p>我们在这里做一点变化，在本章的这部分自由地使用<code>class</code>这个词，因为主题就是模拟类。</p>
</blockquote>
<p>为避免讨论太多细节，我们来看一下<code>JavaScript</code>中一种模拟类的实现。首先，看一下这种方案将如何被使用？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Man = klass(<span class="literal">null</span>, &#123;</span><br><span class="line">  __construct: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Man's constructor"</span>);</span><br><span class="line">    <span class="keyword">this</span>.name = what;</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种语法糖的形式是一个名为<code>klass()</code>的函数。在一些其它的实现方式中，它可能是<code>Klass()</code>构造函数或者是增强的<code>Object.prototype</code>，但是在这个例子中，我们让它只是一个简单的函数。</p>
<p>这个函数接受两个参数：一个被继承的类和通过对象字面量提供的新类的实现。受 PHP 的影响，我们约定类的构造函数必须是一个名为<code>__construct()</code>的方法。在前面的代码片段中，建立了一个名为<code>Man</code>的新类，并且它不继承任何类（意味着继承自<code>Object</code>）。<code>Man</code>类有一个在<code>__construct()</code>建立的自有属性<code>name</code>和一个方法<code>getName()</code>。这个类是一个构造函数，所以下面的代码将正常工作（并且看起来像类实例化的过程）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> first = <span class="keyword">new</span> Man(<span class="string">"Adam"</span>); <span class="comment">// logs "Man's constructor"</span></span><br><span class="line">first.getName(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure>
<p>现在我们来扩展这个类，创建一个<code>SuperMan</code>类：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> SuperMan = klass(Man, &#123;</span><br><span class="line">  __construct: <span class="function"><span class="keyword">function</span> (<span class="params">what</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"SuperMan's constructor"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = SuperMan.uber.getName.call(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I am "</span> + name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这里，<code>klass()</code>的第一个参数是将被继承的<code>Man</code>类。值得注意的是，在<code>getName()</code>中，父类的<code>getName()</code>方法首先通过<code>SuperMan</code>类的<code>uber</code>静态属性被调用。我们来测试一下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clark = <span class="keyword">new</span> SuperMan(<span class="string">"Clark Kent"</span>);</span><br><span class="line">clark.getName(); <span class="comment">// "I am Clark Kent"</span></span><br></pre></td></tr></table></figure>
<p>第一行在<code>console</code>中记录了“<code>Man&#39;s constructor</code>”，然后是“<code>Superman&#39;s constructor</code>”，在一些语言中，父类的构造函数在子类构造函数被调用的时候会自动执行，这个特性也被模拟了。</p>
<p>用<code>instanceof</code>运算符测试返回希望的结果：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clark <span class="keyword">instanceof</span> Man; <span class="comment">// true</span></span><br><span class="line">clark <span class="keyword">instanceof</span> SuperMan; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>最后，我们来看一下<code>klass()</code>函数是怎样实现的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> klass = <span class="function"><span class="keyword">function</span> (<span class="params">Parent, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> Child, F, i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 构造函数</span></span><br><span class="line">  Child = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Child.uber &amp;&amp; Child.uber.hasOwnProperty(<span class="string">"__construct"</span>)) &#123;</span><br><span class="line">      Child.uber.__construct.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Child.prototype.hasOwnProperty(<span class="string">"__construct"</span>)) &#123;</span><br><span class="line">      Child.prototype.__construct.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 继承</span></span><br><span class="line">  Parent = Parent || <span class="built_in">Object</span>;</span><br><span class="line">  F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">  F.prototype = Parent.prototype;</span><br><span class="line">  Child.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  Child.uber = Parent.prototype;</span><br><span class="line">  Child.prototype.constructor = Child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 添加方法实现</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.hasOwnProperty(i)) &#123;</span><br><span class="line">      Child.prototype[i] = props[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回“类”</span></span><br><span class="line">  <span class="keyword">return</span> Child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个<code>klass()</code>实现有三个明显的部分：</p>
<ol>
<li>创建<code>Child()</code>构造函数，这也是最后返回的将被作为类使用的函数。在这个函数里面，如果<code>__construct()</code>方法存在的话将被调用，同样，如果父类的<code>__construct()</code>存在，也将被调用（通过使用静态属性<code>uber</code>）。也可能存在<code>uber</code>没有定义的情况——比如从<code>Object</code>继承，前例中<code>Man</code>类即是如此。</li>
<li>第二部分主要完成继承。只是简单地使用前面章节讨论过的 Holy Grail 类式继承模式。只有一个东西是新的：如果<code>Parent</code>没有传值的话，设定<code>Parent</code>为<code>Object</code>。</li>
<li>最后一部分是真正定义类的地方，遍历需要实现的方法（如例子中的<code>__constructor()</code>和<code>getName()</code>），并将它们添加到<code>Child()</code>的原型中。</li>
</ol>
<p>什么时候使用这种模式呢？其实，最好是能避免则避免，因为它带来了在这门语言中不存在的完整的类的概念，会让人疑惑。使用它需要学习新的语法和新的规则，也就是说，如果你或者你的团队习惯于使用类并且对原型感到不习惯，这种模式可能是一个可以探索的方向。这种模式允许你完全忘掉原型，好处就是你可以使用像其它语言那样的（变种）语法。</p>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>现在，让我们从一个叫作“原型继承”的模式来讨论没有类的现代继承模式。在这种模式中，没有任何类牵涉进来，一个对象继承自另外一个对象。你可以这样理解它：你有一个想复用的对象，然后你想创建第二个对象，并且获得第一个对象的功能。下面是这种模式的用法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要继承的对象</span></span><br><span class="line"><span class="keyword">var</span> parent = &#123;</span><br><span class="line">  name: <span class="string">"Papa"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新对象</span></span><br><span class="line"><span class="keyword">var</span> child = object(parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">alert(child.name); <span class="comment">// "Papa"</span></span><br></pre></td></tr></table></figure>
<p>在这个代码片段中，有一个已经存在的使用对象字面量创建的对象叫<code>parent</code>，我们想创建一个和<code>parent</code>有相同的属性和方法的对象叫<code>child</code>。<code>child</code>对象使用<code>object()</code>函数创建。这个函数在<code>JavaScript</code>中并不存在（不要与构造函数<code>Object()</code>混淆），所以我们来看看怎样定义它。</p>
<p>与<code>Holy Grail</code>类式继承相似，可以使用一个空的临时构造函数<code>F()</code>，然后设定<code>F()</code>的原型为<code>parent</code>对象。最后，返回一个临时构造函数的新实例。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>图 6-9</strong> 展示了使用原型继承时的原型链。这样创建的<code>child</code>总是一个空对象，它没有自有属性但通过原型链（<strong>proto</strong>）拥有父对象的所有功能。</p>
<p><img src="/images/dmfyms/9.png" alt="/images/dmfyms/9.png"></p>
<p>图 6-9 原型继承模式</p>
<p><strong>讨论</strong></p>
<p>在原型继承模式中，<code>parent</code>不一定需要使用对象字面量来创建（尽管这是一种常用的方式），也可以使用构造函数来创建。注意，如果你这样做，那么自有属性和原型上的属性都将被继承：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自有属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Adam"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型上的属性</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Person()创建一个新对象</span></span><br><span class="line"><span class="keyword">var</span> papa = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">var</span> kid = object(papa);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试：自有属性和原型上的属性都被继承了</span></span><br><span class="line">kid.getName(); <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure>
<p>也可以使用这种模式的一个变种，只继承已存在的构造函数的原型对象。记住，对象继承自对象，而不管父对象是怎么创建的。这是前面例子的一个修改版本：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 自有属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"Adam"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型上的属性</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">var</span> kid = object(Person.prototype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> kid.getName; <span class="comment">// "function"，因为它在原型中</span></span><br><span class="line"><span class="keyword">typeof</span> kid.name; <span class="comment">// "undefined"，因为只有原型中的成员被继承了</span></span><br></pre></td></tr></table></figure>
<h3 id="ECMAScript5-中的原型继承"><a href="#ECMAScript5-中的原型继承" class="headerlink" title="ECMAScript5 中的原型继承"></a>ECMAScript5 中的原型继承</h3><p>在<code>ECMAScript5</code>中，原型继承已经正式成为语言的一部分。这种模式使用<code>Object.create()</code>方法来实现。换句话说，你不再需要自己去写类似<code>object()</code>的函数，它是语言原生的部分了：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent);</span><br></pre></td></tr></table></figure>
<p><code>Object.create()</code>接收一个额外的参数——一个对象。这个额外对象中的属性将被作为自有属性添加到返回的子对象中。这让我们可以很方便地将继承和创建子对象在一个方法调用中实现。例如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">  age: &#123; <span class="attr">value</span>: <span class="number">2</span> &#125;, <span class="comment">// ES5中的属性描述符</span></span><br><span class="line">&#125;);</span><br><span class="line">child.hasOwnProperty(<span class="string">"age"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>你可能也会发现原型继承模式已经在一些<code>JavaScript</code>类库中实现了，比如，在<code>YUI3</code>中，它是<code>Y.Object()</code>方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YUI().use(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> child = Y.Object(parent);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="通过复制属性继承"><a href="#通过复制属性继承" class="headerlink" title="通过复制属性继承"></a>通过复制属性继承</h2><p>让我们来看一下另外一种继承模式——通过复制属性继承。在这种模式中，一个对象通过简单地复制另一个对象来获得功能。下面是一个简单的实现这种功能的<code>extend()</code>函数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  child = child || &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.hasOwnProperty(i)) &#123;</span><br><span class="line">      child[i] = parent[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个简单的实现，仅仅是遍历了父对象的成员然后复制它们。在这个实现中，<code>child</code>是可选参数，如果它没有被传入一个已有的对象，那么一个全新的对象将被创建并返回：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dad = &#123; <span class="attr">name</span>: <span class="string">"Adam"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> kid = extend(dad);</span><br><span class="line">kid.name; <span class="comment">// "Adam"</span></span><br></pre></td></tr></table></figure>
<p>上面给出的实现叫作对象的 <code>浅拷贝(shallow copy)</code> ，与之相对，<code>深拷贝</code>是指检查准备复制的属性本身是否是对象或者数组，如果是，也遍历它们的属性并复制。如果使用浅拷贝的话（因为在<code>JavaScript</code>中对象是按引用传递），如果你改变子对象的一个属性，而这个属性恰好是一个对象，那么你也会改变父对象。实际上这对方法来说可能很好（因为函数也是对象，也是按引用传递），但是当遇到其它的对象和数组的时候可能会有些意外情况。考虑这种情况：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dad = &#123;</span><br><span class="line">  counts: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  reads: &#123; <span class="attr">paper</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> kid = extend(dad);</span><br><span class="line">kid.counts.push(<span class="number">4</span>);</span><br><span class="line">dad.counts.toString(); <span class="comment">// "1,2,3,4"</span></span><br><span class="line">dad.reads === kid.reads; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>现在让我们来修改一下<code>extend()</code>函数以便实现深拷贝。你需要做的事情只是检查一个属性的类型是否是对象，如果是，则递归遍历它的属性。另外一个需要做的检查是这个对象是真的对象还是数组，可以使用第三章讨论过的数组检查方式。最终深拷贝版的<code>extend()</code>是这样的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extendDeep</span>(<span class="params">parent, child</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i,</span><br><span class="line">    toStr = <span class="built_in">Object</span>.prototype.toString,</span><br><span class="line">    astr = <span class="string">"[object Array]"</span>;</span><br><span class="line"></span><br><span class="line">  child = child || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.hasOwnProperty(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[i] === <span class="string">"object"</span>) &#123;</span><br><span class="line">        child[i] = toStr.call(parent[i]) === astr ? [] : &#123;&#125;;</span><br><span class="line">        extendDeep(parent[i], child[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        child[i] = parent[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在测试时这个新的实现给了我们对象的真实拷贝，所以子对象不会修改父对象：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dad = &#123;</span><br><span class="line">  counts: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  reads: &#123; <span class="attr">paper</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> kid = extendDeep(dad);</span><br><span class="line"></span><br><span class="line">kid.counts.push(<span class="number">4</span>);</span><br><span class="line">kid.counts.toString(); <span class="comment">// "1,2,3,4"</span></span><br><span class="line">dad.counts.toString(); <span class="comment">// "1,2,3"</span></span><br><span class="line"></span><br><span class="line">dad.reads === kid.reads; <span class="comment">// false</span></span><br><span class="line">kid.reads.paper = <span class="literal">false</span>;</span><br><span class="line">kid.reads.web = <span class="literal">true</span>;</span><br><span class="line">dad.reads.paper; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过复制属性继承的模式很简单且应用很广泛。例如 <strong>Firebug</strong>(JavaScript 写的 Firefox 扩展) 有一个方法叫<code>extend()</code>做浅拷贝，<code>jQuery</code>的<code>extend()</code>方法做深拷贝。<code>YUI3</code>提供了一个叫作<code>Y.clone()</code>的方法，它创建一个深拷贝并且通过绑定到子对象的方式复制函数。（本章后面将有更多关于绑定的内容。）</p>
<p>这种模式并不高深，因为根本没有原型牵涉进来，而只跟对象和它们的属性有关。</p>
<h2 id="混元-Mix-ins"><a href="#混元-Mix-ins" class="headerlink" title="混元 (Mix-ins)"></a>混元 (Mix-ins)</h2><p>既然谈到了通过复制属性来继承，就让我们顺便多说一点，来讨论一下“混元”模式。除了前面说的从一个对象复制，你还可以从任意多数量的对象中复制属性，然后将它们混在一起组成一个新对象。</p>
<p>实现很简单，只需要遍历传入的每个参数然后复制它们的每个属性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arg,</span><br><span class="line">    prop,</span><br><span class="line">    child = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (arg = <span class="number">0</span>; arg &lt; <span class="built_in">arguments</span>.length; arg += <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (prop <span class="keyword">in</span> <span class="built_in">arguments</span>[arg]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>[arg].hasOwnProperty(prop)) &#123;</span><br><span class="line">        child[prop] = <span class="built_in">arguments</span>[arg][prop];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们有了一个通用的混元函数，我们可以传递任意数量的对象进去，返回的结果将是一个包含所有传入对象属性的新对象。下面是用法示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cake = mix(</span><br><span class="line">  &#123; <span class="attr">eggs</span>: <span class="number">2</span>, <span class="attr">large</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">butter</span>: <span class="number">1</span>, <span class="attr">salted</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">flour</span>: <span class="string">"3 cups"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">sugar</span>: <span class="string">"sure!"</span> &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><img src="/images/dmfyms/10.png" alt="/images/dmfyms/10.png"></p>
<p>图 6-10 在 Firebug 中查看 cake 对象</p>
<blockquote>
<p>如果你习惯了某些将混元作为原生部分的语言，那么你可能期望修改一个或多个父对象时也影响子对象。但在这个实现中这是不会发生的事情。这里我们只是简单地遍历、复制自有属性，并没有与父对象有任何链接。</p>
</blockquote>
<h2 id="借用方法"><a href="#借用方法" class="headerlink" title="借用方法"></a>借用方法</h2><p>有时候会有这样的情况：你希望使用某个已存在的对象的一两个方法，你希望能复用它们，但是又真的不希望和那个对象产生继承关系，因为你只希望使用你需要的那一两个方法，而不继承那些你永远用不到的方法。得益于函数的<code>call()</code>和<code>apply()</code>方法，可以通过借用方法模式实现它。在本书中，你其实已经见过这种模式了，甚至在本章<code>extendDeep()</code>的实现中也有用到。</p>
<p>在<code>JavaScript</code>中函数也是对象，它们有一些有趣的方法，比如<code>call()</code>和<code>apply()</code>。这两个方法的唯一区别是后者接受一个参数数组以传入正在调用的方法，而前者只接受一个一个的参数。你可以使用这两个方法来从已有的对象中借用方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call()示例</span></span><br><span class="line">notmyobj.doStuff.call(myobj, param1, p2, p3);</span><br><span class="line"><span class="comment">// apply()示例</span></span><br><span class="line">notmyobj.doStuff.apply(myobj, [param1, p2, p3]);</span><br></pre></td></tr></table></figure>
<p>在这个例子中有一个对象<code>myobj</code>，而且<code>notmyobj</code>有一个用得着的方法叫<code>doStuff()</code>。你可以简单地临时借用<code>doStuff()</code>方法，而不用处理继承然后得到一堆<code>myobj</code>中无关的方法。</p>
<p>你传一个对象和任意的参数，这个被借用的方法会将<code>this</code>绑定到你传递的对象上。简单地说，你的对象会临时假装成另一个对象以使用它的方法。这就像实际上获得了继承但又免除了“继承税”（译注：指不需要的属性和方法）。</p>
<p><strong>例：从数组借用</strong></p>
<p>这种模式的一种常见用法是从数组借用方法。</p>
<p>数组有很多很有用但是一些“类数组”对象（如<code>arguments</code>）不具备的方法。所以<code>arguments</code>可以借用数组的方法，比如<code>slice()</code>。这是一个例子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>); <span class="comment">// returns [2,3]</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，有一个空数组被创建了，因为要借用它的方法。也可以使用一种看起来代码更长的方法来做，那就是直接从数组的原型中借用方法，使用<code>Array.prototype.slice.call(...)</code>。这种方法代码更长一些，但是不用创建一个空数组。在这个例子中，有一个空数组被创建了，因为要借用它的方法。也可以使用一种看起来代码更长的方法来做，那就是直接从数组的原型中借用方法，使用<code>Array.prototype.slice.call(...)</code>。这种方法代码更长一些，但是不用创建一个空数组。</p>
<p><strong>借用并绑定</strong></p>
<p>当借用方法的时候，不管是通过<code>call()</code>/<code>apply()</code>还是通过简单的赋值，方法中的<code>this</code>指向的对象都是基于调用的表达式来决定的。但是有时候最好的使用方式是将<code>this</code>的值锁定或者提前绑定到一个指定的对象上。</p>
<p>我们来看一个例子。这是一个对象<code>one</code>，它有一个<code>say()</code>方法：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = &#123;</span><br><span class="line">  name: <span class="string">"object"</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span> (<span class="params">greet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> greet + <span class="string">", "</span> + <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">one.say(<span class="string">"hi"</span>); <span class="comment">// "hi, object"</span></span><br></pre></td></tr></table></figure>
<p>现在另一个对象<code>two</code>没有<code>say()</code>方法，但是它可以从<code>one</code>借用：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> two = &#123;</span><br><span class="line">  name: <span class="string">"another object"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">one.say.apply(two, [<span class="string">"hello"</span>]); <span class="comment">// "hello, another object"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>say()</code>方法中的<code>this</code>指向了<code>two</code>，<code>this.name</code>是<code>another object</code>。但是如果在某些场景下你将函数赋值给了全局变量或者是将这个函数作为回调，会发生什么？在客户端编程中有非常多的事件和回调，所以这种情况经常发生：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值给变量，this会指向全局对象</span></span><br><span class="line"><span class="keyword">var</span> say = one.say;</span><br><span class="line">say(<span class="string">"hoho"</span>); <span class="comment">// "hoho, undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为回调</span></span><br><span class="line"><span class="keyword">var</span> yetanother = &#123;</span><br><span class="line">  name: <span class="string">"Yet another object"</span>,</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="string">"Hola"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">yetanother.method(one.say); <span class="comment">// "Holla, undefined"</span></span><br></pre></td></tr></table></figure>
<p>在这两种情况中<code>say()</code>中的<code>this</code>都指向了全局对象，所以代码并不像我们想象的那样正常工作。要修复（绑定）一个方法的对象，我们可以用一个简单的函数，像这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">o, m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.apply(o, [].slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>bind()</code>函数接受一个对象<code>o</code>和一个方法<code>m</code>，然后把它们绑定在一起，再返回另一个函数。返回的函数通过闭包可以访问到<code>o</code>和<code>m</code>，也就是说，即使在<code>bind()</code>返回之后，内层的函数仍然可以访问到<code>o</code>和<code>m</code>，而<code>o</code>和<code>m</code>会始终指向原来的对象和方法。让我们用<code>bind()</code>来创建一个新函数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twosay = bind(two, one.say);</span><br><span class="line">twosay(<span class="string">"yo"</span>); <span class="comment">// "yo, another object"</span></span><br></pre></td></tr></table></figure>
<p>正如你看到的，尽管<code>twosay()</code>是作为一个全局函数被创建的，但<code>this</code>并没有指向全局对象，而是指向了通过<code>bind()</code>传入的对象<code>two</code>。不论如何调用<code>twosay()</code>，<code>this</code>将始终指向<code>two</code>。</p>
<p>绑定是奢侈的，你需要付出的代价是<strong>一个额外的闭包</strong>。</p>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p>ECMAScript5 在<code>Function.prototype</code>中添加了一个方法叫<code>bind()</code>，使用时和<code>apply()</code>/<code>call()</code>一样简单。所以你可以这样写：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newFunc = obj.someFunc.bind(myobj, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>这意味着将<code>someFunc()</code>和<code>myobj</code>绑定了,并且还传入了<code>someFunc()</code>的前三个参数。这也是一个在第 4 章讨论过的部分应用的例子。</p>
<p>让我们来看一下当你的程序跑在低于 ES5 的环境中时如何实现<code>Function.prototype.bind()</code>：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.bind === <span class="string">"undefined"</span>) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fn = <span class="keyword">this</span>,</span><br><span class="line">      slice = <span class="built_in">Array</span>.prototype.slice,</span><br><span class="line">      args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(thisArg, args.concat(slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个实现可能看起来有点熟悉，它使用了部分应用，将传入<code>bind()</code>的参数串起来（除了第一个参数），然后在被调用时传给<code>bind()</code>返回的新函数。这是用法示例：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twosay2 = one.say.bind(two);</span><br><span class="line">twosay2(<span class="string">"Bonjour"</span>); <span class="comment">// "Bonjour, another object"</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，除了绑定的对象外，我们没有传任何参数给<code>bind()</code>。下一个例子中，我们来传一个用于部分应用的参数：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twosay3 = one.say.bind(two, <span class="string">"Enchanté"</span>);</span><br><span class="line">twosay3(); <span class="comment">// "Enchanté, another object"</span></span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在<code>JavaScript</code>中，继承有很多种方案可以选择，在本章中你看到了很多类式继承和现代继承的方案。学习和理解不同的模式是有好处的，因为这可以增强你对这门语言的掌握能力。</p>
<p>但是，也许在开发过程中继承并不是你经常面对的一个问题。一部分是因为这个问题已经被使用某种方式或者某个你使用的类库解决了，另一部分是因为你不需要在<code>JavaScript</code>中建立很长很复杂的继承链。在静态强类型语言中，继承可能是唯一可以复用代码的方法，但在<code>JavaScript</code>中有更多更简单更优化的方法，包括借用方法、绑定、复制属性、混元等。</p>
<p>记住，代码复用才是目标，继承只是达成这个目标的一种手段。</p>

        </div>

        
        <section class="post-tags">
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2021/09/25/JS 手写 Promise/">JS 手写 Promise</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Jaythan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src>
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>