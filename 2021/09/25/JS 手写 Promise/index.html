<!DOCTYPE html>
<html lang>

<head><meta name="generator" content="Hexo 3.8.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Jaythan">



    <meta name="description" content="Do not go into that gentle night.">



<title>JS 手写 Promise | Jay&#39;s Blog</title>



    <link rel="icon" href="/image/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->


    


<link rel="alternate" href="/atom.xml" title="Jay's Blog" type="application/atom+xml">
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">Jay&#39;s Blog</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">Jay&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">Posts</a>
                
                    <a class="menu-item" href="/categories">Categories</a>
                
                    <a class="menu-item" href="/tags">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">JS 手写 Promise</h1>
            
                <div class="post-meta">
                    

                    
                        <span class="post-time">
                        Date: <a href="#">September 25, 2021&nbsp;&nbsp;00:00:00</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><a href="https://juejin.cn/post/6994594642280857630" target="_blank" rel="noopener">https://juejin.cn/post/6994594642280857630</a></p>
<h2 id="初始架构"><a href="#初始架构" class="headerlink" title="初始架构"></a>初始架构</h2><ol>
<li>在<code>promise</code>实例被构造的时候，构造方法参数<code>(resolve, reject)⇒{}</code> 是立即执行的，所以这个函数参数要在<code>constructor</code>构造器中调用。</li>
<li>共有三种状态，<code>pending，fulfilled，rejected</code>，需要初始化状态为 <code>pending</code>，结果值为<code>null</code></li>
<li>避免之后调用<code>resolve/reject</code>时，<code>this</code>状态改变，初始化时需要绑定<code>this</code></li>
<li>一旦<code>pending</code>状态变更后，状态不能再改变，所以执行<code>resolve/reject</code>时需要加上条件判断</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">constructor</span>(executor) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        <span class="keyword">this</span>.initValue()</span><br><span class="line">        <span class="comment">// 初始化this指向</span></span><br><span class="line">        <span class="keyword">this</span>.initBind()</span><br><span class="line">        <span class="comment">// 执行传进来的函数</span></span><br><span class="line">        executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initBind() &#123;</span><br><span class="line">        <span class="comment">// 初始化this</span></span><br><span class="line">        <span class="keyword">this</span>.resolve = <span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">this</span>.reject = <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    initValue() &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseResult = <span class="literal">null</span> <span class="comment">// 终值</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseState = <span class="string">'pending'</span> <span class="comment">// 状态</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">		resolve(value) &#123;</span><br><span class="line">        <span class="comment">// state是不可变的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 如果执行resolve，状态变为fulfilled</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseState = <span class="string">'fulfilled'</span></span><br><span class="line">        <span class="comment">// 终值为传进来的值</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseResult = value</span><br><span class="line">		 &#125;</span><br><span class="line">		</span><br><span class="line">		 reject(reason) &#123;</span><br><span class="line">        <span class="comment">// state是不可变的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 如果执行reject，状态变为rejected</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseState = <span class="string">'rejected'</span></span><br><span class="line">        <span class="comment">// 终值为传进来的reason</span></span><br><span class="line">	      <span class="keyword">this</span>.PromiseResult = reason</span><br><span class="line">		 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，如果<code>promise</code>中有<code>throw</code>的话，就相当于执行了<code>reject</code>。这就要使用<code>try catch</code>了</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">// 执行传进来的函数</span></span><br><span class="line">  executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 捕捉到错误直接执行reject</span></span><br><span class="line">	<span class="keyword">this</span>.reject(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-的-Then"><a href="#Promise-的-Then" class="headerlink" title="Promise 的 Then"></a>Promise 的 Then</h2><ol>
<li><code>then</code>接收两个回调，一个是<code>成功回调</code>，一个是<code>失败回调</code></li>
<li>当<code>Promise</code>状态为<code>fulfilled</code>执行<code>成功回调</code>，为<code>rejected</code>执行<code>失败回调</code></li>
<li>如<code>resolve</code>或<code>reject</code>在定时器里，<code>则定时器结束后再执行then</code></li>
<li><code>then</code>支持<code>链式调用</code>，下一次<code>then</code>执行<code>受上一次then返回值的影响</code></li>
</ol>
<h3 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题"></a>定时器问题</h3><p>在下面这个例子中，一秒之后状态才更新</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1秒后输出 ”成功“</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        reject(<span class="string">'失败'</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), err =&gt; <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure>
<p>可以先把<code>then</code>里的两个回调保存起来，然后等到1秒过后，执行<code>resolve</code>或者<code>reject</code>，再去判断状态，并判断要去执行刚刚保存的两个回调中的哪一个回调。</p>
<p><img src="/images/promise/1.png" alt="/images/promise/1.png"></p>
<p>只要状态是<code>pending</code>，那就证明定时器还没跑完，因为如果定时器跑完的话，那状态肯定就不是<code>pending</code>，而是<code>fulfilled/rejected</code>。</p>
<p>可以使用<code>数组</code>来保存回调。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">initValue() &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseResult = <span class="literal">null</span> <span class="comment">// 终值</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseState = <span class="string">'pending'</span> <span class="comment">// 状态</span></span><br><span class="line">+        <span class="keyword">this</span>.onFulfilledCallbacks = [] <span class="comment">// 保存成功回调</span></span><br><span class="line">+        <span class="keyword">this</span>.onRejectedCallbacks = [] <span class="comment">// 保存失败回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolve(value) &#123;</span><br><span class="line">        <span class="comment">// state是不可变的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 如果执行resolve，状态变为fulfilled</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseState = <span class="string">'fulfilled'</span></span><br><span class="line">        <span class="comment">// 终值为传进来的值</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseResult = value</span><br><span class="line">        <span class="comment">// 执行保存的成功回调</span></span><br><span class="line">+        <span class="keyword">while</span> (<span class="keyword">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">+            <span class="keyword">this</span>.onFulfilledCallbacks.shift()(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">+        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reject(reason) &#123;</span><br><span class="line">        <span class="comment">// state是不可变的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 如果执行reject，状态变为rejected</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseState = <span class="string">'rejected'</span></span><br><span class="line">        <span class="comment">// 终值为传进来的reason</span></span><br><span class="line">        <span class="keyword">this</span>.PromiseResult = reason</span><br><span class="line">        <span class="comment">// 执行保存的失败回调</span></span><br><span class="line">+        <span class="keyword">while</span> (<span class="keyword">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">+            <span class="keyword">this</span>.onRejectedCallbacks.shift()(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">+        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    then(onFulfilled, onRejected) &#123;</span><br><span class="line">        <span class="comment">// 接收两个回调 onFulfilled, onRejected</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数校验，确保一定是函数</span></span><br><span class="line">        onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val</span><br><span class="line">        onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前为成功状态，执行第一个回调</span></span><br><span class="line">            onFulfilled(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前为失败状态，执行第二哥回调</span></span><br><span class="line">            onRejected(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">**+        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState === <span class="string">'pending'</span>) &#123;</span><br><span class="line">+            <span class="comment">// 如果状态为待定状态，暂时保存两个回调</span></span><br><span class="line">+            <span class="keyword">this</span>.onFulfilledCallbacks.push(onFulfilled.bind(<span class="keyword">this</span>))</span><br><span class="line">+            <span class="keyword">this</span>.onRejectedCallbacks.push(onRejected.bind(<span class="keyword">this</span>))**</span><br><span class="line">+        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h3><p><code>then</code>支持<code>链式调用</code>，下一次<code>then</code>执行受上一次<code>then</code>返回值的影响。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用 输出 200</span></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">100</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="number">2</span> * res, err =&gt; <span class="built_in">console</span>.log(err))</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), err =&gt; <span class="built_in">console</span>.log(err))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式调用 输出300</span></span><br><span class="line"><span class="keyword">const</span> p4 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">100</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> resolve(<span class="number">3</span> * res)), err =&gt; <span class="built_in">console</span>.log(err))</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res), err =&gt; <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure>
<ol>
<li><code>then</code>方法本身会返回一个新的<code>Promise</code>对象</li>
<li>如果返回值是<code>promise</code>对象，返回值为成功，新<code>promise</code>就是成功</li>
<li>如果返回值是<code>promise</code>对象，返回值为失败，新<code>promise</code>就是失败</li>
<li>如果返回值非<code>promise</code>对象，新<code>promise</code>对象就是成功，值为此返回值</li>
</ol>
<p>因此，<code>then</code>执行后返回一个<code>Promise</code>对象，就能保证<code>then</code>完还能继续执行<code>then</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="comment">// 接收两个回调 onFulfilled, onRejected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数校验，确保一定是函数</span></span><br><span class="line">    onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">val</span> =&gt;</span> val</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> thenPromise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> resolvePromise = <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> x = cb(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">                <span class="keyword">if</span> (x === thenPromise) &#123;</span><br><span class="line">                    <span class="comment">// 不能返回自身哦</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能返回自身。。。'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                    <span class="comment">// 如果返回值是Promise</span></span><br><span class="line">                    <span class="comment">// 如果返回值是promise对象，返回值为成功，新promise就是成功</span></span><br><span class="line">                    <span class="comment">// 如果返回值是promise对象，返回值为失败，新promise就是失败</span></span><br><span class="line">                    <span class="comment">// 谁知道返回的promise是失败成功？只有then知道</span></span><br><span class="line">                    x.then(resolve, reject)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 非Promise就直接成功</span></span><br><span class="line">                    resolve(x)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                <span class="comment">// 处理报错</span></span><br><span class="line">                reject(err)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前为成功状态，执行第一个回调</span></span><br><span class="line">            resolvePromise(onFulfilled)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前为失败状态，执行第二个回调</span></span><br><span class="line">            resolvePromise(onRejected)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.PromiseState === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果状态为待定状态，暂时保存两个回调</span></span><br><span class="line">            <span class="comment">// 如果状态为待定状态，暂时保存两个回调</span></span><br><span class="line">            <span class="keyword">this</span>.onFulfilledCallbacks.push(resolvePromise.bind(<span class="keyword">this</span>, onFulfilled))</span><br><span class="line">            <span class="keyword">this</span>.onRejectedCallbacks.push(resolvePromise.bind(<span class="keyword">this</span>, onRejected))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回这个包装的Promise</span></span><br><span class="line">    <span class="keyword">return</span> thenPromise</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p><code>then</code>方法是<code>微任务</code>，使用定时器，让<code>resolvePromise</code>函数异步执行，模拟微任务。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = cb(<span class="keyword">this</span>.PromiseResult)</span><br><span class="line">            <span class="keyword">if</span> (x === thenPromise) &#123;</span><br><span class="line">                <span class="comment">// 不能返回自身哦</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'不能返回自身。。。'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                <span class="comment">// 如果返回值是Promise</span></span><br><span class="line">                <span class="comment">// 如果返回值是promise对象，返回值为成功，新promise就是成功</span></span><br><span class="line">                <span class="comment">// 如果返回值是promise对象，返回值为失败，新promise就是失败</span></span><br><span class="line">                <span class="comment">// 谁知道返回的promise是失败成功？只有then知道</span></span><br><span class="line">                x.then(resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非Promise就直接成功</span></span><br><span class="line">                resolve(x)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 处理报错</span></span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><h3 id="all"><a href="#all" class="headerlink" title="all"></a><strong>all</strong></h3><ul>
<li>接收一个<code>Promise</code>数组，数组中如有非<code>Promise</code>项，则此项当做成功</li>
<li>如果所有<code>Promise</code>都成功，则返回成功结果数组</li>
<li>如果有一个<code>Promise</code>失败，则返回这个失败结果</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> all(promises) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = []</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> addData = <span class="function">(<span class="params">index, value</span>) =&gt;</span> &#123;</span><br><span class="line">            result[index] = value</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">if</span> (count === promises.length) resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, index</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    addData(index, res)</span><br><span class="line">                &#125;, err =&gt; reject(err))</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addData(index, promise)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><ul>
<li>接收一个<code>Promise</code>数组，数组中如有非<code>Promise</code>项，则此项当做成功</li>
<li>哪个<code>Promise</code>最快得到结果，就返回那个结果，无论成功失败</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> race(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        promises.forEach(<span class="function"><span class="params">promise</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(res)</span><br><span class="line">                &#125;, err =&gt; &#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(promise)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="allSettled"><a href="#allSettled" class="headerlink" title="allSettled"></a>allSettled</h3><ul>
<li>接收一个<code>Promise</code>数组，数组中如有非<code>Promise</code>项，则此项当做成功</li>
<li>把每一个<code>Promise</code>的结果，集合成数组，返回</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> allSettled(promises) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> res = []</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">const</span> addData = <span class="function">(<span class="params">status, value, i</span>) =&gt;</span> &#123;</span><br><span class="line">            res[i] = &#123;</span><br><span class="line">                status,</span><br><span class="line">                value</span><br><span class="line">            &#125;</span><br><span class="line">            count++</span><br><span class="line">            <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">                resolve(res)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        promises.forEach(<span class="function">(<span class="params">promise, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (promise <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">                promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">                    addData(<span class="string">'fulfilled'</span>, res, i)</span><br><span class="line">                &#125;, err =&gt; &#123;</span><br><span class="line">                    addData(<span class="string">'rejected'</span>, err, i)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addData(<span class="string">'fulfilled'</span>, promise, i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><ul>
<li>接收一个Promise数组，数组中如有非Promise项，则此项当做成功</li>
<li>如果有一个Promise成功，则返回这个成功结果</li>
<li>如果所有Promise都失败，则报错</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">static</span> any(promises) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">	        <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">	        promises.forEach(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">	            promise.then(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">	                resolve(val)</span><br><span class="line">	            &#125;, err =&gt; &#123;</span><br><span class="line">	                count++</span><br><span class="line">	                <span class="keyword">if</span> (count === promises.length) &#123;</span><br><span class="line">	                    reject(<span class="keyword">new</span> AggregateError(<span class="string">'All promises were rejected'</span>))</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;)</span><br><span class="line">	        &#125;)</span><br><span class="line">	    &#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h3><ul>
<li>如果可以用 async await 的话，那么可以用 while 循环，通过同步的语法实现</li>
<li>如果不能用 async await 的话，那么可以用 Promise 递归调用的方法实现</li>
</ul>
<p>如果要求两次请求间隔一段时间，用 promise 会更方便</p>
<p><strong>在外层使用 async</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.retry = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">fn, times = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(times);</span><br><span class="line">    times--;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="keyword">await</span> fn();</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> (times === <span class="number">0</span>) <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>在内层使用 async</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.retry = <span class="function"><span class="keyword">function</span> (<span class="params">promiseFn, times = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="keyword">async</span> (resolve, reject) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(times);</span><br><span class="line">      times--;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ret = <span class="keyword">await</span> promiseFn();</span><br><span class="line">        resolve(ret);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times === <span class="number">0</span>) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>使用 promise</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.retry = <span class="function"><span class="keyword">function</span> (<span class="params">fn, times = <span class="number">3</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">retry</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(times);</span><br><span class="line">      times--;</span><br><span class="line">      fn()</span><br><span class="line">        .then(resolve)</span><br><span class="line">        .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (times === <span class="number">0</span>) &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            retry();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    retry();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://juejin.cn/post/6994594642280857630" target="_blank" rel="noopener">看了就会，手写Promise原理，最通俗易懂的版本</a></li>
</ol>

        </div>

        
        <section class="post-tags">
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2021/09/30/dmfyms/">代码复用模式</a>
            
            
            <a class="next" rel="next" href="/2021/09/15/performance/">【转】 前端性能指标</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Jaythan | Powered by <a href="https://hexo.io" target="_blank">Hexo</a></span>
    </div>
</footer>

    </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src>
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>

</html>