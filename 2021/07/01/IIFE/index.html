<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> IIFE-立即调用函数表达式 · Jay's Blog</title><meta name="description" content="IIFE-立即调用函数表达式 - Jaythan"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://12vv.github.io/atom.xml" title="Jay's Blog"><link rel="alternate" href="/atom.xml" title="Jay's Blog" type="application/atom+xml">
<!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://jay-ye.vercel.app/" target="_blank" class="nav-list-link">PORTFOLIO</a></li><li class="nav-list-item"><a href="https://github.com/12vv" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">IIFE-立即调用函数表达式</h1><div class="post-info">Jul 1, 2021</div><div class="post-content"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>立即调用的匿名函数又被称作立即调用的函数表达式<code>(IIFE, Immediately Invoked Function Expression)</code>。</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>它类似于函数声明，但由于被包含在括号中，所以会被解释为<code>函数表达式</code>。</p>
<a id="more"></a>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am IIFE"</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// w3c 标准建议使用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am IIFE"</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 箭头函数写法</span></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"I am IIFE"</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>如果以<code>function</code>开头，则会被识别为函数声明，<strong>函数声明是不能被被执行符号<code>()</code>执行的！</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>); <span class="comment">// Uncaught SyntaxError: </span></span><br><span class="line">											<span class="comment">// Function statements require a function name</span></span><br><span class="line">&#125;();                  <span class="comment">// 这个报错是因为函数声明一定要有函数名</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>); <span class="comment">// Uncaught SyntaxError: Unexpected token ')'</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>只要是函数表达式，就可以加执行符号达到立即执行的效果了。</p>
<p>也可以加上一元操作符将函数转成表达式 (不推荐使用)。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加上操作符，编译器不再认为这是一个函数声明</span></span><br><span class="line"></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);<span class="comment">// 1</span></span><br><span class="line">&#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);<span class="comment">// 2</span></span><br><span class="line">&#125;();</span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);<span class="comment">// 3</span></span><br><span class="line">&#125;()</span><br><span class="line">,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);<span class="comment">// 4</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>很多人习惯在前面加<code>**;**</code>，就是为了避免两个立即执行函数连在一起时发生如下错误：以下代码只能输出一个<code>a</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    console.log('a');</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">(function()&#123;</span><br><span class="line">    console.log('b');</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">// Uncaught TypeError: (intermediate value)(...) is not a function</span><br></pre></td></tr></table></figure>
<p>再补充一个奇怪的情况：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>这里不会报错，也不会输出，实际上这种写法会被解释成<strong>一个函数声明，还有一个无意义的表达式</strong>。也就是下面的样子：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个表达式</span></span><br><span class="line">(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><strong>关于非匿名自执行函数</strong></p>
<p>注意：立即执行函数也是可以加名字的，但是要注意，<strong>函数名<code>只读</code></strong>。看下面这个例子</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	b = <span class="number">20</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure>
<p>在非严格模式下会输出<code>**[Function b]**</code>，在严格模式下会报错！<code>Uncaught TypeError: Assignment to constant variable.</code></p>
<p>原因就在于匿名函数属于表达式的范畴，如果添加了名字，遵从<strong>具名函数表达式</strong>的规范。</p>
<p>函数表达式中函数的识别名是不需要的，有名称的函数表达式，就是<code>**具名函数表达式 (Named function expressions, NFE)**</code>，其函数的识别名，它的作用域是<strong>只在函数的主体内部</strong>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	b = <span class="number">10</span>;                 <span class="comment">// 严格模式下改行报错</span></span><br><span class="line">  <span class="built_in">console</span>.log(b);         <span class="comment">// [Function b]</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">window</span>.b);  <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(b);   <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="进行初始化"><a href="#进行初始化" class="headerlink" title="进行初始化"></a>进行初始化</h3><p>在<code>ES6</code>的<code>let</code>和<code>const</code>，可以用立即执行函数来模拟块级作用域，避免全局变量污染。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">"bar"</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">foo; <span class="comment">// ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>类似的，有一些操作需要在页面加载完成立即执行，比如绑定事件、创建对象等，也需要一些临时的变量，但是之后不会再用到。这时候使用立即执行函数，将这些初始化代码包裹在其局部作用域中，就是个很好的方案。</p>
<p>下面这个例子在初始化时绑定监听事件，<code>count</code>变量不会被泄漏出去，而且点击事件也能正常运作。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hi"</span>, count++);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h3 id="模块化封装"><a href="#模块化封装" class="headerlink" title="模块化封装"></a>模块化封装</h3><p>使用一个立即执行函数创建的闭包，实现对象字面量创建对象的私有成员。以此来封装模块，暴露的接口成为公有方法以供调用，私有成员外部无法取得。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myobj = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 私有成员</span></span><br><span class="line">	<span class="keyword">var</span> name = <span class="string">"my, oh my"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实现公有部分</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">myobj.getName(); <span class="comment">// "my, oh my"</span></span><br></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="经典题"><a href="#经典题" class="headerlink" title="经典题"></a>经典题</h3><p>下面这道经典题目</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网上很多解释是说是因为事件队列的原因，说因为回调函数被放到事件队列中，<code>for</code>循环执行完毕<code>i</code>的值已经变成了<code>5</code>，再执行<code>5</code>个<code>console.log(i)</code>所以会输出<code>5</code>个<code>5</code>。</p>
<p>开始我看到这种解释有些困惑，为什么换成<code>let</code>就能解决呢？如果说是因为事件循环的原因，那换成<code>let</code>，循环完毕<code>i</code>也变成<code>5</code>了。</p>
<p>之后我补充了作用域，作用域链，执行上下文等知识，才了解到这种现象是由于作用域造成的。</p>
<p>之所以使用<code>let</code>就可以得到期望结果，是由于<code>let</code>的块级作用域，每一轮循环都会有一个新的词法作作用域环境保存每一轮的<code>**i**</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">blockLexicalEnvironment = &#123;</span><br><span class="line">  i: <span class="number">0</span>,</span><br><span class="line">  outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br><span class="line">blockLexicalEnvironment = &#123;</span><br><span class="line">  i: 1,</span><br><span class="line">  outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br><span class="line">blockLexicalEnvironment = &#123;</span><br><span class="line">  i: 2,</span><br><span class="line">  outer: &lt;globalLexicalEnvironment&gt;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>之后执行<code>console.log(i)</code>，由于当前作用域没有<code>i</code>，所以沿着<strong>作用域链</strong>找，即找到了他上一层的块级词法环境中的<code>i</code>。</p>
<p>所以使用这里使用立即执行函数也是同样的原理。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) &#123;</span><br><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">  &#125;(i))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的<br>作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p>
</blockquote>
<h3 id="立即执行函数的递归"><a href="#立即执行函数的递归" class="headerlink" title="立即执行函数的递归"></a>立即执行函数的递归</h3><p>立即执行函数是如果不加名字，又想要自身递归调用怎么办呢？可以使用<code>[arguments.callee](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments/callee)</code>，已在ES5严格模式中被废弃，了解原因可以看<a href="https://stackoverflow.com/questions/103598/why-was-the-arguments-callee-caller-property-deprecated-in-javascript" target="_blank" rel="noopener">这里</a>。</p>
<blockquote>
<p><code>callee</code>是<code>arguments</code>对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> init = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(init);    <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure>
<p>当然，可以使用<strong>具名函数</strong>直接调用，如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> init = (<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> n * a(n<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(init);    <span class="comment">// 3628800</span></span><br></pre></td></tr></table></figure>
<h3 id="关于变量提升"><a href="#关于变量提升" class="headerlink" title="关于变量提升"></a>关于变量提升</h3><p>匿名函数属于函数表达式，创建执行上下文时不会被提升。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);       <span class="comment">// 正常输出</span></span><br><span class="line"><span class="built_in">console</span>.log(sayName);   <span class="comment">// Uncaught ReferenceError: sayName is not defined</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;)(<span class="string">'Millzie'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53" target="_blank" rel="noopener">https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53</a></p>
<p><a href="https://stackoverflow.com/questions/103598/why-was-the-arguments-callee-caller-property-deprecated-in-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/103598/why-was-the-arguments-callee-caller-property-deprecated-in-javascript</a></p>
<p>Kyle Simpson. 2014. You Don’t Know JS: Scope &amp; Closures (1st. ed.). O’Reilly Media, Inc.</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/02/29/stcg05/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 - 2021 <a href="https://12vv.github.io">Jaythan</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>